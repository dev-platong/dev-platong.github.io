<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>dev-platong's home - Android, ExoPlayer</title><link href="/" rel="alternate"></link><link href="/feeds/android-exoplayer.atom.xml" rel="self"></link><id>/</id><updated>2023-03-10T00:00:00+09:00</updated><entry><title>ExoPlayerのLoaderファイナルクラス</title><link href="/exoplayernoloaderhuainarukurasu.html" rel="alternate"></link><published>2023-03-10T00:00:00+09:00</published><updated>2023-03-10T00:00:00+09:00</updated><author><name>dev-platong</name></author><id>tag:None,2023-03-10:/exoplayernoloaderhuainarukurasu.html</id><summary type="html">&lt;h1&gt;Overview&lt;/h1&gt;
&lt;p&gt;HlsSampleStreamWrapperを見ていたら、出てきたので軽めに触れる。&lt;/p&gt;
&lt;h2&gt;責務&lt;/h2&gt;
&lt;p&gt;Loadableインターフェースを持つもののバックグラウンドでの管理。&lt;/p&gt;
&lt;h2&gt;基 …&lt;/h2&gt;</summary><content type="html">&lt;h1&gt;Overview&lt;/h1&gt;
&lt;p&gt;HlsSampleStreamWrapperを見ていたら、出てきたので軽めに触れる。&lt;/p&gt;
&lt;h2&gt;責務&lt;/h2&gt;
&lt;p&gt;Loadableインターフェースを持つもののバックグラウンドでの管理。&lt;/p&gt;
&lt;h2&gt;基底&lt;/h2&gt;
&lt;p&gt;LoaderErrorThrower：条件によって例外をスローするか判断する &lt;code&gt;maybeThrowError()&lt;/code&gt;を持つ。&lt;/p&gt;
&lt;h2&gt;空間&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;upstream&lt;/code&gt; 空間&lt;/p&gt;
&lt;h1&gt;定義クラス・例外・インターフェース&lt;/h1&gt;
&lt;h2&gt;例外：UnexpectedLoaderException&lt;/h2&gt;
&lt;p&gt;IOExceptionの拡張。特別な機能は持たない。&lt;/p&gt;
&lt;h1&gt;インターフェース：Loadable&lt;/h1&gt;
&lt;h2&gt;責務&lt;/h2&gt;
&lt;p&gt;Loaderによってloadされるオブジェクト&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cancelLoad()&lt;/code&gt; メソッドと &lt;code&gt;load()&lt;/code&gt; メソッドを持つ。&lt;/p&gt;
&lt;h2&gt;インターフェース；Callback(T extends Loadable)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;void onLoadCompleted(T loadable, long elapsedRealtimeMs, long loadDurationMs)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void onLoadCancled(T loadable, long elapsedRealtimeMs, long loadDurationMs, boolean released)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LoadErrorAction onLoadError(T loadable, long elapsedRealtimeMs, long loadDurationMs, IOException error, int errorCount)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="Android, ExoPlayer"></category></entry><entry><title>ExoPlayerのBufferクラス</title><link href="/exoplayernobufferkurasu.html" rel="alternate"></link><published>2023-03-09T00:00:00+09:00</published><updated>2023-03-09T00:00:00+09:00</updated><author><name>dev-platong</name></author><id>tag:None,2023-03-09:/exoplayernobufferkurasu.html</id><summary type="html">&lt;h1&gt;Overview&lt;/h1&gt;
&lt;p&gt;SampleStreamに渡されるDecoderInputBufferを掘っていく途中で基底となるBuffer抽象クラスを見ます。&lt;/p&gt;
&lt;h1&gt;責務&lt;/h1&gt;
&lt;p&gt;バッファとフラグの基底クラス。&lt;/p&gt;
&lt;h2&gt;フラ …&lt;/h2&gt;</summary><content type="html">&lt;h1&gt;Overview&lt;/h1&gt;
&lt;p&gt;SampleStreamに渡されるDecoderInputBufferを掘っていく途中で基底となるBuffer抽象クラスを見ます。&lt;/p&gt;
&lt;h1&gt;責務&lt;/h1&gt;
&lt;p&gt;バッファとフラグの基底クラス。&lt;/p&gt;
&lt;h2&gt;フラグの6種類&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;KEY_FRAME：バッファが同期サンプルを持っていることを示す。&lt;/li&gt;
&lt;li&gt;END_OF_STREAM：EOSのシグナルとなるからのバッファであることを示す。&lt;/li&gt;
&lt;li&gt;HAS_SUPPLEMENTAL_DATA：バッファが補完的なデータを持っていることを示す。&lt;/li&gt;
&lt;li&gt;LAST_SAMPLE：ストリームの最後のメディアサンプルであることを知られているものを含んでいることを示す。&lt;/li&gt;
&lt;li&gt;ENCRYPTED：バッファが一部または全て暗号化されている。&lt;/li&gt;
&lt;li&gt;DECODE_ONLY：レンダリングされないものを示す。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.17.0/library%2Fcommon%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FC.java#L480-L510"&gt;C.java#L480-L510&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.17.0/library/decoder/src/main/java/com/google/android/exoplayer2/decoder/Buffer.java"&gt;Buffer.java&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;振る舞い&lt;/h2&gt;
&lt;p&gt;Bufferクラスでは主にフラグの扱いを定義している。&lt;br&gt;
持っているフラグから、 &lt;code&gt;isDecodeOnly&lt;/code&gt; かなどを判定しているだけ。&lt;br&gt;
フラグはset/add/clearできる。&lt;/p&gt;
&lt;h1&gt;まとめ&lt;/h1&gt;
&lt;p&gt;フラグについての振る舞いしか定義されていない。フラグは6つある。&lt;/p&gt;</content><category term="Android, ExoPlayer"></category></entry><entry><title>ExoPlayerのDecoderInputBufferクラス</title><link href="/exoplayernodecoderinputbufferkurasu.html" rel="alternate"></link><published>2023-03-09T00:00:00+09:00</published><updated>2023-03-09T00:00:00+09:00</updated><author><name>dev-platong</name></author><id>tag:None,2023-03-09:/exoplayernodecoderinputbufferkurasu.html</id><summary type="html">&lt;h1&gt;Overview&lt;/h1&gt;
&lt;p&gt;SampleStreamで &lt;code&gt;readData()&lt;/code&gt; 時に渡される &lt;code&gt;DecoderInputBuffer&lt;/code&gt; クラスについて調べる。&lt;/p&gt;
&lt;h2&gt;責務&lt;/h2&gt;
&lt;p&gt;デコーダへの入力を保持します。  &lt;/p&gt;
&lt;h2&gt;基底&lt;/h2&gt;
&lt;p&gt;&lt;a href="./exoplayer_buffer.md"&gt;Buffer抽象クラス&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;@BufferReplacementMode&lt;/h2&gt;
&lt;p&gt;既存のバ …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Overview&lt;/h1&gt;
&lt;p&gt;SampleStreamで &lt;code&gt;readData()&lt;/code&gt; 時に渡される &lt;code&gt;DecoderInputBuffer&lt;/code&gt; クラスについて調べる。&lt;/p&gt;
&lt;h2&gt;責務&lt;/h2&gt;
&lt;p&gt;デコーダへの入力を保持します。  &lt;/p&gt;
&lt;h2&gt;基底&lt;/h2&gt;
&lt;p&gt;&lt;a href="./exoplayer_buffer.md"&gt;Buffer抽象クラス&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;@BufferReplacementMode&lt;/h2&gt;
&lt;p&gt;既存のバッファのキャパシティが十分でない場合に&lt;code&gt;ensureSpaceForWrite&lt;/code&gt; でどのように置換バッファを生成するかをコントロールします。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BUFFER_REPLACEMENT_MODE_DISABLED&lt;/li&gt;
&lt;li&gt;BUFFER_REPLACEMENT_MODE_NORMAL： &lt;code&gt;ByteBuffer.allocate(int)&lt;/code&gt;を用いたバッファ置換を許容します。&lt;/li&gt;
&lt;li&gt;BUFFER_REPLACEMENT_MODE_DIRECT： &lt;code&gt;ByteBuffer.allocateDirect(int)&lt;/code&gt; を用いたバッファ置換を許容します。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;InsufficientCapacityExceptionファイナルクラス&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;BUFFER_REPLACEMENT_MODE_DISABLED&lt;/code&gt; または 十分なキャパシティを持っていない場合の DocoderInputBufferへの書き込み時にスローします。&lt;/p&gt;
&lt;h2&gt;保持するByteBuffer&lt;/h2&gt;
&lt;p&gt;dataフィールドにデータを持つことはもちろんですが、supplementalDataを持つ可能性もあります。&lt;br&gt;
バッファは補完データを持つ場合にはポジション0からそのリミットまでバッファが入力されます。&lt;/p&gt;
&lt;h2&gt;その他関連クラス&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Format&lt;/li&gt;
&lt;li&gt;CryptInfo&lt;/li&gt;
&lt;li&gt;Nullable ByteBuffer&lt;/li&gt;
&lt;/ul&gt;</content><category term="Android, ExoPlayer"></category></entry><entry><title>ExoPlayerのFormatクラス</title><link href="/exoplayernoformatkurasu.html" rel="alternate"></link><published>2023-03-09T00:00:00+09:00</published><updated>2023-03-09T00:00:00+09:00</updated><author><name>dev-platong</name></author><id>tag:None,2023-03-09:/exoplayernoformatkurasu.html</id><summary type="html">&lt;h1&gt;概要&lt;/h1&gt;
&lt;p&gt;SampleStreamがreadData()する際に渡される FormatHolder から掘り下げます。&lt;/p&gt;
&lt;h2&gt;責務&lt;/h2&gt;
&lt;p&gt;メディアフォーマットを表現します。finalクラスです。&lt;/p&gt;
&lt;h3&gt;全てのフ …&lt;/h3&gt;</summary><content type="html">&lt;h1&gt;概要&lt;/h1&gt;
&lt;p&gt;SampleStreamがreadData()する際に渡される FormatHolder から掘り下げます。&lt;/p&gt;
&lt;h2&gt;責務&lt;/h2&gt;
&lt;p&gt;メディアフォーマットを表現します。finalクラスです。&lt;/p&gt;
&lt;h3&gt;全てのフォーマットに共通する8つのフィールド&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;id（Nullable String）&lt;/li&gt;
&lt;li&gt;label&lt;/li&gt;
&lt;li&gt;language&lt;/li&gt;
&lt;li&gt;selectionFlags&lt;/li&gt;
&lt;li&gt;roleFlags&lt;/li&gt;
&lt;li&gt;averageBitrate&lt;/li&gt;
&lt;li&gt;codecs&lt;/li&gt;
&lt;li&gt;metadata&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;コンテナフォーマットに共通するフィールド&lt;/h3&gt;
&lt;p&gt;コンテナMIME TYPEを持つ場合。&lt;br&gt;
コンテナが単一のメディアトラックしか含まない場合は、後述のサンプルフォーマットと同じになります。&lt;/p&gt;
&lt;h3&gt;サンプルフォーマットに共通するフィールド&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;sampleMimeType&lt;/li&gt;
&lt;li&gt;maxInputsize&lt;/li&gt;
&lt;li&gt;initializationData&lt;/li&gt;
&lt;li&gt;drmInitData&lt;/li&gt;
&lt;li&gt;subsampleOffsetUs&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;ビデオフォーマットに共通するフィールド&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;width&lt;/li&gt;
&lt;li&gt;height&lt;/li&gt;
&lt;li&gt;frameRate&lt;/li&gt;
&lt;li&gt;rotationDegrees&lt;/li&gt;
&lt;li&gt;pixelWidthHeightRatio&lt;/li&gt;
&lt;li&gt;projectionData&lt;/li&gt;
&lt;li&gt;stereoMode&lt;/li&gt;
&lt;li&gt;colorInfo&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;音声フォーマットに共通するフィールド&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;channelCount&lt;/li&gt;
&lt;li&gt;sampleRate&lt;/li&gt;
&lt;li&gt;pcmEncoding&lt;/li&gt;
&lt;li&gt;encoderDelay&lt;/li&gt;
&lt;li&gt;encoderPadding&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;テキストフォーマットに共通するフィールド&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;accessibilityChannel&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;メソッドなど&lt;/h1&gt;
&lt;p&gt;getter/setterの他に、copyや音声サンプルフォーマットなどを想定した &lt;code&gt;createAudioSampleFormat()&lt;/code&gt; などがありますが、基本的にはデータの塊と捉えていいのではない得ていいのでは。&lt;/p&gt;
&lt;p&gt;https://github.com/google/ExoPlayer/blob/r2.17.0/library%2Fcommon%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FFormat.java&lt;/p&gt;</content><category term="Android, ExoPlayer"></category></entry><entry><title>ExoPlayerのHlsSampleStreamファイナルクラス</title><link href="/exoplayernohlssamplestreamhuainarukurasu.html" rel="alternate"></link><published>2023-03-07T00:00:00+09:00</published><updated>2023-03-07T00:00:00+09:00</updated><author><name>dev-platong</name></author><id>tag:None,2023-03-07:/exoplayernohlssamplestreamhuainarukurasu.html</id><summary type="html">&lt;h1&gt;Overview&lt;/h1&gt;
&lt;p&gt;SampleStreamを読んだので、その実装クラスを見ていきます。&lt;/p&gt;
&lt;h1&gt;責務&lt;/h1&gt;
&lt;p&gt;HLSの中の特定のサンプルキューを表現します。&lt;/p&gt;
&lt;h1&gt;HlsSampleStreamWrapperファイナル …&lt;/h1&gt;</summary><content type="html">&lt;h1&gt;Overview&lt;/h1&gt;
&lt;p&gt;SampleStreamを読んだので、その実装クラスを見ていきます。&lt;/p&gt;
&lt;h1&gt;責務&lt;/h1&gt;
&lt;p&gt;HLSの中の特定のサンプルキューを表現します。&lt;/p&gt;
&lt;h1&gt;HlsSampleStreamWrapperファイナルクラス&lt;/h1&gt;
&lt;p&gt;こちらが本体といってもいいほど巨大なクラスです。&lt;/p&gt;</content><category term="Android, ExoPlayer"></category></entry><entry><title>ExoPlayerのSampleStreamインターフェース</title><link href="/exoplayernosamplestreamintahuesu.html" rel="alternate"></link><published>2023-03-07T00:00:00+09:00</published><updated>2023-03-07T00:00:00+09:00</updated><author><name>dev-platong</name></author><id>tag:None,2023-03-07:/exoplayernosamplestreamintahuesu.html</id><summary type="html">&lt;h1&gt;概要&lt;/h1&gt;
&lt;p&gt;Rendererインターフェースによる動画データの描画の挙動を追っていく過程です。&lt;br&gt;
Rendererがデータを読み込んでいるSampleStreamに …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;概要&lt;/h1&gt;
&lt;p&gt;Rendererインターフェースによる動画データの描画の挙動を追っていく過程です。&lt;br&gt;
Rendererがデータを読み込んでいるSampleStreamについて触れます。&lt;/p&gt;
&lt;h2&gt;SampleStreamインターフェースの責務&lt;/h2&gt;
&lt;p&gt;フォーマット情報が紐づいたメディアサンプルのストリームを表現します。&lt;/p&gt;
&lt;h2&gt;空間&lt;/h2&gt;
&lt;p&gt;sourceパッケージです（&lt;code&gt;com.google.android.exoplayer2.source&lt;/code&gt;）。&lt;/p&gt;
&lt;h2&gt;4つのメソッド&lt;/h2&gt;
&lt;h3&gt;boolean isReady()&lt;/h3&gt;
&lt;p&gt;読み込み可能なデータが利用できるかを返します。&lt;br&gt;
EOSは常にreadyであることに注意します。&lt;/p&gt;
&lt;h3&gt;void maybeThrowError() throws IOException&lt;/h3&gt;
&lt;p&gt;読み込み時にデータが阻害された場合エラーを吐きます。&lt;/p&gt;
&lt;h3&gt;@ReadDataResult int readData(FormatHolder formatHolder, DecoderInputBuffer buffer, @ReadFlags int readFlags)&lt;/h3&gt;
&lt;h4&gt;@ReadDataResult&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;RESULT_NOTHING_READ&lt;/code&gt; または &lt;code&gt;RESULT_FORMAT_READ&lt;/code&gt;・ &lt;code&gt;RESULT_BUFFER_READ&lt;/code&gt;が帰ります。&lt;br&gt;
何も読めなかったか、フォーマットかバッファーかです。&lt;/p&gt;
&lt;h4&gt;FormatHolderファイナルクラス&lt;/h4&gt;
&lt;p&gt;FormatクラスとDrmSessionクラスを保持します。&lt;/p&gt;
&lt;h5&gt;Formatファイナルクラス&lt;/h5&gt;
&lt;p&gt;&lt;a href="./exoplayer_format.md"&gt;記事&lt;/a&gt;をご覧ください。&lt;/p&gt;
&lt;h4&gt;DecoderInputBuffer&lt;/h4&gt;
&lt;p&gt;&lt;a href="./exoplayer_decoder_input_buffer.md"&gt;記事&lt;/a&gt;をご覧ください。&lt;/p&gt;
&lt;h4&gt;ReadFlags&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;FLAG_PEEK：サンプルバッファが読み込まれる時、読み込みポジションは先に進むべきでは無いことを示します。&lt;/li&gt;
&lt;li&gt;FLAG_REQUIRE_FORMAT：次にバッファが読まれるときに、サンプルのフォーマットを代わりに読みます。&lt;/li&gt;
&lt;li&gt;FLAG_OMIT_SAMPLE_DATA： &lt;code&gt;{@link DecoderInputBuffer#data}, {@link DecoderInputBuffer#supplementalData} と {@link DecoderInputBuffer#cryptoInfo}&lt;/code&gt;を呼ぶ必要がないことを伝えます。効率的なサンプルメタデータのピーキングや、サンプルバッファのスキップに利用されます。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;int skipData（long positionUs）&lt;/h3&gt;
&lt;p&gt;特定のポジション以前のキーフレームをスキップすることを試みます。または、&lt;code&gt;positionUs&lt;/code&gt; が EOS(End of stream)を超えている場合、データをスキップします。&lt;/p&gt;
&lt;h1&gt;まとめ&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;4つのメソッドがある。&lt;/li&gt;
&lt;li&gt;読み込む・スキップする・準備可能・エラーをスローする。&lt;/li&gt;
&lt;li&gt;DocoderInputBufferとFormatHolderが関係する。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;明日はFormatクラスについて扱います。&lt;/p&gt;</content><category term="Android, ExoPlayer"></category></entry><entry><title>ExoPlayerのSequenceableLoaderインターフェース</title><link href="/exoplayernosequenceableloaderintahuesu.html" rel="alternate"></link><published>2023-03-07T00:00:00+09:00</published><updated>2023-03-07T00:00:00+09:00</updated><author><name>dev-platong</name></author><id>tag:None,2023-03-07:/exoplayernosequenceableloaderintahuesu.html</id><summary type="html">&lt;h1&gt;Overview&lt;/h1&gt;
&lt;p&gt;HlsSampleWrapperがimplementsしているので。&lt;/p&gt;
&lt;h2&gt;責務&lt;/h2&gt;
&lt;p&gt;他のローダーと同期的に進行可能なローダー。&lt;/p&gt;
&lt;h2&gt;基底&lt;/h2&gt;
&lt;p&gt;なし&lt;/p&gt;
&lt;h2&gt;空間&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;source&lt;/code&gt;&lt;/p&gt;
&lt;h1&gt;インターフェース&lt;/h1&gt;
&lt;h2&gt;Callback&lt;T extends SequencableLoader&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;void onContinueLoadingRequested …&lt;/code&gt;&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Overview&lt;/h1&gt;
&lt;p&gt;HlsSampleWrapperがimplementsしているので。&lt;/p&gt;
&lt;h2&gt;責務&lt;/h2&gt;
&lt;p&gt;他のローダーと同期的に進行可能なローダー。&lt;/p&gt;
&lt;h2&gt;基底&lt;/h2&gt;
&lt;p&gt;なし&lt;/p&gt;
&lt;h2&gt;空間&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;source&lt;/code&gt;&lt;/p&gt;
&lt;h1&gt;インターフェース&lt;/h1&gt;
&lt;h2&gt;Callback&lt;T extends SequencableLoader&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;void onContinueLoadingRequested(T source)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;continueLoading(long)&lt;/code&gt;を呼ぶことを期待するコールバック。再生スレッドから呼ばれる。 &lt;/p&gt;
&lt;h2&gt;メソッド&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;long getBufferedPositionUs()&lt;/code&gt;・&lt;code&gt;long getNextLoadPositionUs()&lt;/code&gt;はそのまま。&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;boolean continueLoading(long positionUs)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;継続的なローディングを試みます。&lt;code&gt;True&lt;/code&gt;を返す場合には進行が得られたことを示し、 &lt;code&gt;getNextLoadPosition()&lt;/code&gt; の値が呼び出し前と変わることを意味します。&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;boolean isLoading()&lt;/code&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;code&gt;void reevaluateBuffer(long positionUs)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;異なる品質に変わったならばリバッファリングします。&lt;/p&gt;</content><category term="Android, ExoPlayer"></category></entry><entry><title>ExoPlayerのsetMediaItemを読んだ時</title><link href="/exoplayernosetmediaitemwodu-ndashi.html" rel="alternate"></link><published>2023-02-28T00:00:00+09:00</published><updated>2023-02-28T00:00:00+09:00</updated><author><name>dev-platong</name></author><id>tag:None,2023-02-28:/exoplayernosetmediaitemwodu-ndashi.html</id><summary type="html">&lt;h2&gt;ExoPlayer.setMediaItemを呼びます。&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ExoPlayerImpl.setMediaSourcesInternal()&lt;/code&gt; が呼ばれます。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java#L1529"&gt;exoplayer2/ExoPlayerImpl.java#L1529&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;仰々しいですが、やっていることは &lt;code&gt;internalPlayer.setMediaSources()&lt;/code&gt; を呼び、 &lt;code&gt;updatePlaybackInfo()&lt;/code&gt; を呼びます。&lt;/p&gt;
&lt;h2&gt;ExoPlayerImplInternal.setMediaSources()&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;MSG_SET_MEDIA_SOURCES …&lt;/code&gt;&lt;/p&gt;</summary><content type="html">&lt;h2&gt;ExoPlayer.setMediaItemを呼びます。&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ExoPlayerImpl.setMediaSourcesInternal()&lt;/code&gt; が呼ばれます。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java#L1529"&gt;exoplayer2/ExoPlayerImpl.java#L1529&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;仰々しいですが、やっていることは &lt;code&gt;internalPlayer.setMediaSources()&lt;/code&gt; を呼び、 &lt;code&gt;updatePlaybackInfo()&lt;/code&gt; を呼びます。&lt;/p&gt;
&lt;h2&gt;ExoPlayerImplInternal.setMediaSources()&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;MSG_SET_MEDIA_SOURCES&lt;/code&gt; を Targetに送ります。そして自身の &lt;code&gt;setMediaItemsInternal()&lt;/code&gt; を呼びます。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L522-L523"&gt;ExoPlayerImplInternal.java#L522-L523&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/029a2b27cbdc27cf9d51d4a73ebeb503968849f6/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L692"&gt;ExoPlayerImplInternal.java#L692&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最終的に&lt;code&gt;handleMediaSourceListInfoRefreshed()&lt;/code&gt;が呼ばれます。このメソッドは長すぎるので明日。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/029a2b27cbdc27cf9d51d4a73ebeb503968849f6/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L1793"&gt;ExoPlayerImplInternal.java#L1793&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;private ExoPlayerImplInternal.handleMediaSourceListInfoRefreshed(Timeline timeline, boolean isSourceRefresh)&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L1793"&gt;ExoPlayerImplInternal.java#L1793&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;resolvePositionForPlaylistChange(Timeline timeline, PlaybackInfo playbackInfo, @Nullable SeekPosition pendingInitialSeekPosition, MediaPeriodQueue queue, @RepeatMode int repeatMode, boolean shuffleModeEnabled, Timeline.Window window, Timeline.Period period)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L2508"&gt;ExoPlayerImplInternal.java#L2508&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;SeekPosition&lt;/h4&gt;
&lt;p&gt;データクラスです（&lt;code&gt;private static final class&lt;/code&gt; ）。&lt;br&gt;
&lt;code&gt;Timeline&lt;/code&gt;・&lt;code&gt;int windowIndex&lt;/code&gt;・&lt;code&gt;long windowPositionUs&lt;/code&gt; を持ちます。これにより &lt;strong&gt;シークにはPeriodという概念が関係ない（windowとwindow内の位置が決まればいい）&lt;/strong&gt; ということがわかります。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/029a2b27cbdc27cf9d51d4a73ebeb503968849f6/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L2922"&gt;ExoPlayerImplInternal.java#L2922&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;特徴的なのは、まず &lt;code&gt;Timeline&lt;/code&gt; に関して。 位置の特定が必要な場合には、 &lt;code&gt;Timeline&lt;/code&gt; ・ &lt;code&gt;Timeline.Window&lt;/code&gt;・ &lt;code&gt;Timeline・Period&lt;/code&gt; が渡されます。&lt;br&gt;
そして &lt;code&gt;Timeline&lt;/code&gt; は empty の場合があることにも注意しなければなりません。SEE：&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L2517"&gt;ExoPlayerImplInternal.java#L2517&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;次に、 MediaPeriodIdとPeriodUidの扱いです。MediaPeriodIdは &lt;code&gt;old&lt;/code&gt; なのに対し、 &lt;code&gt;PeriodUid&lt;/code&gt; に関しては &lt;code&gt;new&lt;/code&gt; として扱っています。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L2526-L2527"&gt;ExoPlayerImplInternal.java#L2526-L2527&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;次の &lt;code&gt;Timeline.Period&lt;/code&gt; がプレースホルダーである場合についての言及です。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L2528"&gt;ExoPlayerImplInternal.java#L2528&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;isUsingPlaceholderPeriod()&lt;/code&gt; は &lt;code&gt;Timeline.Period.isPlaceholder&lt;/code&gt; を使って確認します（この時 Timeline.isEmptyに関する検査はアーリーリターンをしているため不要です）。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L2682-L2687"&gt;ExoPlayerImplInternal.java#L2682-L2687&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;そして、 &lt;code&gt;oldContentPosition&lt;/code&gt; を ad かどうかとプレースホルダーかどうかに留意しながら決定します。 &lt;code&gt;newContentPosition&lt;/code&gt; は一時的に &lt;code&gt;oldContentPosition&lt;/code&gt; と一致させます（のちに変更するわけです）。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L2529-L2533"&gt;ExoPlayerImplInternal.java#L2529-L2533&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;その後に、シークを考慮しながら以下の値を決定していきます。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;int startAtDefaultPositionWindowIndex = C.INDEX_UNSET;
boolean forceBufferingState = false;
boolean endPlayback = false;
boolean setTargetLiveOffset = false;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/029a2b27cbdc27cf9d51d4a73ebeb503968849f6/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L2534-L2537"&gt;ExoPlayerImplInternal.java#L2534-L2537&lt;/a&gt;&lt;/p&gt;
&lt;h5&gt;一度目のペンディングされたシークかどうか&lt;/h5&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/029a2b27cbdc27cf9d51d4a73ebeb503968849f6/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L2538"&gt;ExoPlayerImplInternal.java#L2538&lt;/a&gt;&lt;/p&gt;
&lt;h6&gt;resolveSeekPosition&lt;/h6&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/029a2b27cbdc27cf9d51d4a73ebeb503968849f6/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L2796"&gt;ExoPlayerImplInternal.java#L2796&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;引数として、位置の特定に必要な &lt;code&gt;Timeline&lt;/code&gt;・&lt;code&gt;Timeline.Window&lt;/code&gt;・&lt;code&gt;Timeline.Period&lt;/code&gt;と &lt;code&gt;SeekPosition&lt;/code&gt;、後はパラメータ類です。（&lt;code&gt;boolean trySubsequentPeriods, @RepeatMode int repeatMode, boolean shuffleModeEnabled&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;中身は複雑なので深く触れませんが、 &lt;code&gt;Timeline.getPeriodPosition(window, period, seekPosition.windowIndex, seekPosition.windowPositionUs);&lt;/code&gt; を読んでその値を返します。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;resolveSeekPosition()&lt;/code&gt;が呼ばれ、結果がnullなら &lt;code&gt;endPlayback = true, startAtDefaultPositionWindowIndex = timeline.getFirstWindowIndex(shuffleModeEnabled);&lt;/code&gt; となります。これはどうやらinitial seekに失敗した場合のようです。  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;かなり曖昧なので、明日も続きを書いていきます。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;PositionUpdateForPlaylistChange&lt;/h3&gt;
&lt;p&gt;名前の通りのデータクラスです。&lt;br&gt;
&lt;code&gt;private final static class&lt;/code&gt; なので、完全に &lt;code&gt;ExoPlayerImplInternal&lt;/code&gt; のみで利用されます （ExoPlayerImplInternalの1つの特徴でこのクラスより下の階層のクラスがないためだと考えます）。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L2935"&gt;ExoPlayerImplInternal.java#L2935&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;やはりExoPlayerImplInternalのあるメソッドまで落ちてくる。 &lt;code&gt;resolveSeekPosition()&lt;/code&gt; の続きからは https://github.com/dev-platong/dev-platong.github.io/issues/19。&lt;/p&gt;</content><category term="Android, ExoPlayer"></category></entry><entry><title>SimpleExoPlayerの生成時</title><link href="/simpleexoplayernosheng-cheng-shi.html" rel="alternate"></link><published>2023-02-27T00:00:00+09:00</published><updated>2023-02-27T00:00:00+09:00</updated><author><name>dev-platong</name></author><id>tag:None,2023-02-27:/simpleexoplayernosheng-cheng-shi.html</id><summary type="html">&lt;h2&gt;Constructing時に関連するクラス・プロパティ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;PriorityTaskManager： その名の通り優先的にタスクを実行するクラス&lt;/li&gt;
&lt;li&gt;AudioAttributes： 全てのAPIでサポートでき …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;h2&gt;Constructing時に関連するクラス・プロパティ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;PriorityTaskManager： その名の通り優先的にタスクを実行するクラス&lt;/li&gt;
&lt;li&gt;AudioAttributes： 全てのAPIでサポートできる android.media.AudioAttributes の強化版&lt;/li&gt;
&lt;li&gt;VideoScalingMode： クロップかfitするためのスケールしかない。デフォルトはfit。MediaCodecベースの Renderer が利用可能で、SurfaceViewが出力に指定されている時に利用できる。&lt;/li&gt;
&lt;li&gt;VideoChangeFrameRateStrategy：後述&lt;/li&gt;
&lt;li&gt;skipSilenceEnabled：無音の音声ストリームをスキップするか、デフォルトはfalse&lt;/li&gt;
&lt;li&gt;detachSurfaceTimeoutMs： プレイヤーからSurfaceがデタッチされるタイムアウト秒数（ms）。&lt;/li&gt;
&lt;li&gt;ComponentListener： 一般的な説明は後述。SimpleExoPlayerは、AnalyticsCollectorと、個別に登録したlisntersに処理を委譲するだけだが、例外もいくつかあるため都度覗くこと。&lt;/li&gt;
&lt;li&gt;FrameMetadataListener：ビデオフレームに紐付くメタデータのリッスンと、カメラモーションのリッスン。&lt;/li&gt;
&lt;li&gt;renderes：RendererFactoryから生成します。&lt;/li&gt;
&lt;li&gt;volume：デフォルトで1です。&lt;/li&gt;
&lt;li&gt;currentCues：空のリスト&lt;/li&gt;
&lt;li&gt;throwsWhenUsingWrongThread：デフォルトでtrueです。再生スレッド以外からプレイヤーが触れられた時に例外をスローします。&lt;/li&gt;
&lt;li&gt;AudioBecomingNoisyManager：後述&lt;/li&gt;
&lt;li&gt;AudioFocusManager：　Audio Focusが何のことか分からないので&lt;a href="https://github.com/dev-platong/dev-platong.github.io/issues/12"&gt;いずれ調べます。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;StreamVolumeManager： android.media.AudioManagerのラップクラスです。音声ストリームのボリュームを扱います。&lt;/li&gt;
&lt;li&gt;WakeLockManager：&lt;a href="https://developer.android.com/training/scheduling/wakelock?hl=ja"&gt;androidのWakeLock&lt;/a&gt;を扱います。&lt;/li&gt;
&lt;li&gt;WifiLockManager：&lt;a href="https://developer.android.com/reference/android/net/wifi/WifiManager.WifiLock"&gt;androidのWifiLock&lt;/a&gt;を扱います。&lt;/li&gt;
&lt;li&gt;DeviceInfo：再生しているデバイスの情報を持ちます。といってもローカルかリモートか（キャスト）とminVolumeとmaxVolumeくらいです。（命名変更が求められるところ）&lt;/li&gt;
&lt;li&gt;videoSize：VideoSize.UNKNOWNで生成されます。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;その後は、rendererにメッセージをセットして終わりです。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java#L430"&gt;SimpleExoPlayer.java#L430&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;VideoChangeFrameRateStrategy&lt;/h3&gt;
&lt;p&gt;MediaCodecベースのRendererが利用可能な場合に利用できる。&lt;br&gt;
アプリケーションは、 Surfaceの &lt;code&gt;CHANGE_FRAME_RATE_ALWAYS&lt;/code&gt; を &lt;code&gt;C#VIDEO_CHANGE_FRAME_RATE_STRATEGY_OFF&lt;/code&gt; にセットした上で、ExoPlayerが &lt;code&gt;Surface#setFrameRate&lt;/code&gt; を操作して実現する。&lt;/p&gt;
&lt;h3&gt;ComponentListener&lt;/h3&gt;
&lt;p&gt;ExoPlayerでは、各クラスでprivate finalで実装されているリスナーです。&lt;/p&gt;
&lt;h3&gt;AudioBecomingNoisyManager&lt;/h3&gt;
&lt;p&gt;デフォルトではBuilderの &lt;code&gt;handleAudioBecomingNoisy&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; のため、機能しません。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayer.java#L422"&gt;ExoPlayer.java#L422&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;この機能を &lt;code&gt;true&lt;/code&gt; にする場合には、&lt;code&gt;AUDIO_BECOMING_NOIDY&lt;/code&gt; の検出時に &lt;code&gt;playWhenReady&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; になります。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java#L2032-L2037"&gt;SimpleExoPlayer.java#L2032-L2037&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;ExoPlayerImplやExoPlayerImplInternalで具体的な処理を行うため、SimpleExoではより付加価値的なクラス生成を行なっている。&lt;br&gt;
明日は&lt;a href="./exoplayer_set_media_item.md"&gt;ExoPlayer.setMediaItem()を追います。&lt;/a&gt;&lt;/p&gt;</content><category term="Android, ExoPlayer"></category></entry><entry><title>LivePlaybackSpeedControlの詳細（アルゴリズム）</title><link href="/liveplaybackspeedcontrolnoxiang-xi-arugorizumu.html" rel="alternate"></link><published>2023-02-26T00:00:00+09:00</published><updated>2023-02-26T00:00:00+09:00</updated><author><name>dev-platong</name></author><id>tag:None,2023-02-26:/liveplaybackspeedcontrolnoxiang-xi-arugorizumu.html</id><summary type="html">&lt;h2&gt;maybeXXXに&lt;/h2&gt;
&lt;p&gt;ExoPlayerには &lt;code&gt;maybeXXX()&lt;/code&gt; というメソッドが多々ある。&lt;br&gt;
何かしらの副作用を引き起こす可能性があるメソッドであり、読むときは条 …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;maybeXXXに&lt;/h2&gt;
&lt;p&gt;ExoPlayerには &lt;code&gt;maybeXXX()&lt;/code&gt; というメソッドが多々ある。&lt;br&gt;
何かしらの副作用を引き起こす可能性があるメソッドであり、読むときは条件に注目して読むことになる。&lt;/p&gt;
&lt;h2&gt;TargetLiveOffsetのリセット&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;maybeResetTargetLiveOffset()&lt;/code&gt; が &lt;code&gt;LiveConfiguration&lt;/code&gt; が更新されるか、&lt;code&gt;targetLiveOffset&lt;/code&gt; が更新される場合に呼ばれます。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/release-v2/library/core/src/main/java/com/google/android/exoplayer2/DefaultLivePlaybackSpeedControl.java#L299-L322"&gt;DefaultLivePlaybackSpeedControl.java#L299-L322&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;targetLiveOffsetOverrideUs&lt;/code&gt; があれば、これを &lt;code&gt;idealTargetLiveOffset&lt;/code&gt; と &lt;code&gt;currentTargetLiveOffset&lt;/code&gt; に設定する。
 ない場合には LiveConfiguration経由のtargetOffset （ &lt;code&gt;mediaConfigurationTargetLiveOffsetUs&lt;/code&gt; ） を設定する。&lt;/p&gt;
&lt;p&gt;すでに &lt;code&gt;idealTargetLiveOffset&lt;/code&gt; が &lt;code&gt;idealOffsetUs&lt;/code&gt; と同じ秒数だった場合にはアーリーリターンする。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;smoothedMinPossibleLiveOffsetUs&lt;/li&gt;
&lt;li&gt;smoothedMinPossibleLiveOffsetDeviationUs&lt;/li&gt;
&lt;li&gt;lastPlaybackSpeedUpdateMs&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;がリセットされる。&lt;/p&gt;
&lt;h2&gt;リバッファリングが起きた時、&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;targetLiveOffsetRebufferDeltaUs&lt;/code&gt; 　の分だけ &lt;code&gt;currentTargetLiveOffsetUs&lt;/code&gt; を増やし、 &lt;code&gt;lastPlaybackSpeedUpdateMs&lt;/code&gt; をアンセットします。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/DefaultLivePlaybackSpeedControl.java#L321"&gt;DefaultLivePlaybackSpeedControl.java#L321&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;平滑化（線形）&lt;/h2&gt;
&lt;p&gt;引数として渡された2つの値を、&lt;code&gt;smoothingFactor&lt;/code&gt; の割合で足し合わせます。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nv"&gt;private&lt;/span&gt; &lt;span class="nv"&gt;static&lt;/span&gt; &lt;span class="nv"&gt;long&lt;/span&gt; &lt;span class="nv"&gt;smooth&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;long&lt;/span&gt; &lt;span class="nv"&gt;smoothedValue&lt;/span&gt;, &lt;span class="nv"&gt;long&lt;/span&gt; &lt;span class="nv"&gt;newValue&lt;/span&gt;, &lt;span class="nv"&gt;float&lt;/span&gt; &lt;span class="nv"&gt;smoothingFactor&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt; {
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;long&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt; &lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;smoothingFactor&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nv"&gt;smoothedValue&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="nv"&gt;f&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;smoothingFactor&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nv"&gt;newValue&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;&lt;span class="c1"&gt;;&lt;/span&gt;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/DefaultLivePlaybackSpeedControl.java#L443-L445"&gt;DefaultLivePlaybackSpeedControl.java#L443-L445&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;SmoothedMinPossibleLiveOffsetUs のアップデート&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;liveOffsetUs&lt;/code&gt; と &lt;code&gt;bufferedDurationUs&lt;/code&gt; の差をとり &lt;code&gt;minPossibleLiveOffsetUs&lt;/code&gt; とします。仮に &lt;code&gt;liveOffset&lt;/code&gt; が 8us、 &lt;code&gt;bugfferedDurationUs&lt;/code&gt; が 5us の場合、 &lt;code&gt;minPossibleLiveOffsetUs&lt;/code&gt; は 3us となります。&lt;/p&gt;
&lt;p&gt;その後、  &lt;code&gt;minPossibleLiveOffsetUs&lt;/code&gt; そのままのものと、 &lt;code&gt;minPossibleLiveOffsetUs&lt;/code&gt; と &lt;code&gt;smoothedMinPossibleLiveOffsetUs&lt;/code&gt; で 平滑化したものを比較し大きい方を &lt;code&gt;smoothedMinPossibleLiveOffsetUs&lt;/code&gt; とします。これは安全で可能な値のうち、トラックをより良い値に保持すべきだからです。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/DefaultLivePlaybackSpeedControl.java#L394-L402"&gt;DefaultLivePlaybackSpeedControl.java#L394-L402&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;minPossibleLiveOffsetDeviationUs&lt;/code&gt; は &lt;code&gt;minPossibleLiveOffsetUs&lt;/code&gt; と &lt;code&gt;smoothedMinPossibleLiveOffsetUs&lt;/code&gt; の差です。（&lt;code&gt;minPossibleLiveOffsetUs&lt;/code&gt; が採択された場合この値は0になります。）&lt;/p&gt;
&lt;h2&gt;TargetLiveOffsetの調整&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;safeOffsetUs&lt;/code&gt; を minPossibleLiveOffsetDeviationUs を &lt;code&gt;smoothedMinPossibleLiveOffsetUs + 3 * smoothedMinPossibleLiveOffsetDeviationUs;&lt;/code&gt; と定義します。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;currentTargetLiveOffsetUs&lt;/code&gt; の値を &lt;code&gt;safeOffsetUs&lt;/code&gt; に近づけていきます。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/DefaultLivePlaybackSpeedControl.java#L413"&gt;DefaultLivePlaybackSpeedControl.java#L413&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;調整後のスピードの取得&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;mediaConfigurationTargetLiveOffsetUs&lt;/code&gt; が TIME_UNSET の場合は常に1です。（狙うOffsetがないため）&lt;/p&gt;
&lt;p&gt;引数として渡された &lt;code&gt;liveOffset&lt;/code&gt; で &lt;code&gt;currentTargetLiveOffset&lt;/code&gt; の値を変化させたのちに、その差をとります。（currentTargetLiveOffsetはsafeOffsetに寄っているため値に差が出ます。）&lt;/p&gt;
&lt;p&gt;この値が速度を変化させるべき値となるため、その値にFactorをかけて速度を調整します。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/DefaultLivePlaybackSpeedControl.java#L334"&gt;DefaultLivePlaybackSpeedControl.java#L334&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;線形平滑化を利用する。（前回の値を考慮する）&lt;/li&gt;
&lt;li&gt;前回の値を考慮しながらtargetOffsetを調整している。&lt;/li&gt;
&lt;li&gt;速度の調整は、渡されたTargetOffsetからcurrentTargetOffsetの値を前回の値を考慮しつつ変化させ、差を取って決定する。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;明日はExoPlayer生成時に戻り、&lt;a href="./exoplayer_constructing_simpleexoplayer.md"&gt;SimpleExoPlayerの生成時に何が起きるかを追います。&lt;/a&gt;&lt;/p&gt;</content><category term="Android, ExoPlayer"></category></entry><entry><title>Low Latency時に快適な再生：LivePlaybackSpeedControlの挙動を追う</title><link href="/low-latencyshi-nikuai-shi-nazai-sheng-liveplaybackspeedcontrolnoju-dong-wozhui-u.html" rel="alternate"></link><published>2023-02-25T00:00:00+09:00</published><updated>2023-02-25T00:00:00+09:00</updated><author><name>dev-platong</name></author><id>tag:None,2023-02-25:/low-latencyshi-nikuai-shi-nazai-sheng-liveplaybackspeedcontrolnoju-dong-wozhui-u.html</id><summary type="html">&lt;h2&gt;Live再生時にMediaに設定される LiveConfigurationクラス&lt;/h2&gt;
&lt;p&gt;オフセットと再生速度のmin/maxが設定できる。オフセットに関してはターゲット …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;Live再生時にMediaに設定される LiveConfigurationクラス&lt;/h2&gt;
&lt;p&gt;オフセットと再生速度のmin/maxが設定できる。オフセットに関してはターゲットも設定できる。&lt;/p&gt;
&lt;h2&gt;LivePlaybackSpeedControlインターフェース&lt;/h2&gt;
&lt;p&gt;ターゲットオフセットは、 &lt;code&gt;LivePlaybackSpeedControl&lt;/code&gt; から上書きできる。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/release-v2/library/core/src/main/java/com/google/android/exoplayer2/LivePlaybackSpeedControl.java#L41"&gt;LivePlaybackSpeedControl.java#L41&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ユーザーインタラクションではないリバッファリングの検知も行う。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/release-v2/library/core/src/main/java/com/google/android/exoplayer2/LivePlaybackSpeedControl.java#L50"&gt;LivePlaybackSpeedControl.java#L50&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;現在のオフセット位置とバッファ位置を渡すことで、調整のための速度を返すメソッドがある。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/release-v2/library/core/src/main/java/com/google/android/exoplayer2/LivePlaybackSpeedControl.java#L60"&gt;LivePlaybackSpeedControl.java#L60&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;現在のターゲットオフセットは外部からも取得可能（隠蔽したい意図はないらしい、内部的に変更されることがあるのか？）&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/release-v2/library/core/src/main/java/com/google/android/exoplayer2/LivePlaybackSpeedControl.java#L66"&gt;LivePlaybackSpeedControl.java#L66&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;DefaultLivePlaybackSpeedControl&lt;/h2&gt;
&lt;p&gt;速度のコントロールメカニズムは比例制御を利用する。 &lt;code&gt;1.0 + 比例制御定数 * （ 現在のライブオフセット秒数 - ターゲットライブオフセット秒数 ）&lt;/code&gt; で表される。&lt;/p&gt;
&lt;p&gt;比例制御定数はデフォルトで &lt;code&gt;0.1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;リバッファリングが起きた時、&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Builder#setTargetLiveOffsetIncrementOnRebufferMs(long targetLiveOffsetIncrementOnRebufferMs)&lt;/code&gt; の分だけ、target offsetが増加し、ネットワークケイパビリティが縮小する。&lt;/p&gt;
&lt;p&gt;状況が改善すると、&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Builder#setMinPossibleLiveOffsetSmoothingFactor(float minPossibleLiveOffsetSmoothingFactor)&lt;/code&gt; の分だけ、target offsetが縮小する。注意するのは秒数をしているするのではなく、ファクターであると。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/release-v2/library/core/src/main/java/com/google/android/exoplayer2/DefaultLivePlaybackSpeedControl.java#L31"&gt;DefaultLivePlaybackSpeedControl.java#L31&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;デフォルトの速度はMin 0.97 / Max 1.03 倍で設定されている。&lt;br&gt;
速度アップデートの感覚はデフォルトで1秒おき。&lt;/p&gt;
&lt;p&gt;リバッファリングが起きた時に、ライブオフセットの秒数はデフォルトで0.5秒増える。&lt;/p&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;LivePlaybackSpeedControlでは、ターゲットオフセットに狙って速度を変更する。&lt;/li&gt;
&lt;li&gt;ターゲットオフセットは内部の振る舞いにより変更される。&lt;/li&gt;
&lt;li&gt;DefaultLivePlaybackSpeedControlでは比例制御が行われる。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;明日はより詳細に&lt;a href="./exoplayer_detail_of_liveplaybackspeedcontrol.md"&gt;アルゴリズムを追います。&lt;/a&gt;&lt;/p&gt;</content><category term="Android, ExoPlayer"></category></entry><entry><title>ExoPlayerImplInternalの挙動を追う（生成まわり）</title><link href="/exoplayerimplinternalnoju-dong-wozhui-usheng-cheng-mawari.html" rel="alternate"></link><published>2023-02-24T00:00:00+09:00</published><updated>2023-02-24T00:00:00+09:00</updated><author><name>dev-platong</name></author><id>tag:None,2023-02-24:/exoplayerimplinternalnoju-dong-wozhui-usheng-cheng-mawari.html</id><summary type="html">&lt;h2&gt;ExoPlayerImplInternalの生成時&lt;/h2&gt;
&lt;h3&gt;LoadControl関連&lt;/h3&gt;
&lt;p&gt;LoadControl から 巻き戻し関連の値を取得する。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L248-L249"&gt;ExoPlayerImplInternal.java#L248-L249&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;PlaybackInfo関連&lt;/h3&gt;
&lt;p&gt;ダミーのPlaybackInfoインスタンスと、それに基づく PlaybackInfoUpdateク …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;ExoPlayerImplInternalの生成時&lt;/h2&gt;
&lt;h3&gt;LoadControl関連&lt;/h3&gt;
&lt;p&gt;LoadControl から 巻き戻し関連の値を取得する。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L248-L249"&gt;ExoPlayerImplInternal.java#L248-L249&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;PlaybackInfo関連&lt;/h3&gt;
&lt;p&gt;ダミーのPlaybackInfoインスタンスと、それに基づく PlaybackInfoUpdateクラスを作る。&lt;/p&gt;
&lt;p&gt;PlaybackInfoUpdateクラスは ExoPlayerImplInternal で定義されるクラス。&lt;br&gt;
保持されている PlaybackInfo の情報が外部に伝わっているとは限らない（pengingされている）。&lt;br&gt;
&lt;code&gt;void incrementPendingOperationAcks(int operationAcks)&lt;/code&gt; が呼び出されるタイミングで pending が解除される。&lt;br&gt;
&lt;code&gt;incrementPendingOperationAcks&lt;/code&gt; は ExoPlayerImpl と ExoPlayerImplInternal だけで使用される。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L251-L252"&gt;ExoPlayerImplInternal.java#L251-L252&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Renderer関連&lt;/h3&gt;
&lt;p&gt;Rendererの再生特性（DRMをサポートするか・トンネルモードをサポートするかなど）を配列で保持する。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L253-L257"&gt;ExoPlayerImplInternal.java#L253-L257&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;PlayerMessage関連&lt;/h3&gt;
&lt;h4&gt;PlayerMessageクラス&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;package com.google.android.exoplayer2&lt;/code&gt; にある、Playerに何か挙動を引き起こすためメッセージ。スレッドが死んでいる場合に実行を中止したり、pendingしたりできる点でCommandパターンに近い。&lt;/p&gt;
&lt;p&gt;Senderインターフェースを実装するものから送出され、Targetインターフェースを持つものが受け取る。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/PlayerMessage.java"&gt;PlayerMessage.java&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;PendingMessageInfo&lt;/h4&gt;
&lt;p&gt;ExoPlayerImplInternal特有のクラス。PlayerMessageがどの位置で解決されたかを、&lt;code&gt;periodIndex&lt;/code&gt;, &lt;code&gt;periodTimeUs&lt;/code&gt;, &lt;code&gt;periodUid&lt;/code&gt; で保持する。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L259"&gt;ExoPlayerImplInternal.java#L259&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Timeline関連&lt;/h3&gt;
&lt;p&gt;Timeline.WindowとTimeline.Periodをそれぞれフィールドに保持する。&lt;/p&gt;
&lt;p&gt;もしTimelineに詳しくない場合はわかりやすい&lt;a href="https://exoplayer.dev/doc/reference/com/google/android/exoplayer2/Timeline.html"&gt;com/google/android/exoplayer2/Timeline.html&lt;/a&gt;を参照のこと。&lt;/p&gt;
&lt;p&gt;この時、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Windowは 単一のwindow uidと空のmediaItem&lt;/li&gt;
&lt;li&gt;Periodは 広告再生ステートではない状態&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;で生成される。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L261-L262"&gt;ExoPlayerImplInternal.java#L261-L262&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;TrackSelector関連&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;init(InvalidationListener listener, BandwidthMeter bandwidthMeter)&lt;/code&gt; が呼ばれるが、引数をフィールドに保持するだけのため、一般的なソフトウェアにおいてはコンストラクタのような内容である。しかしExoPlayerはサブコンポーネントの振る舞いをDIよって変更できる設計であるため、コンストラクタがその旨で利用される。そのためこちらは&lt;code&gt;init&lt;/code&gt;となっているのではないかと推察できる。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;InvalidationListener&lt;/code&gt; は、以前のトラック選択で選択され利用中の &lt;code&gt;Track&lt;/code&gt; を失効させるための処理を担うハンドラのリスナー。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L263"&gt;ExoPlayerImplInternal.java#L263&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;MediaPeriodQueueクラス&lt;/h3&gt;
&lt;p&gt;MediaPeriodを保持し、先頭のメディアが読まれるキュー。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/029a2b27cbdc27cf9d51d4a73ebeb503968849f6/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodQueue.java#L33-L37"&gt;MediaPeriodQueue.java#L33-L37&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ExoPlayerImplInternalのコンストラクタで生成される。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L268"&gt;ExoPlayerImplInternal.java#L268&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;MediaPeriodQueueクラスのコンストラクタでPeriodとWindowを生成するが、これは ExoPlayerImplInternalのPeriod・Windowインスタンスとは別物であることに注意。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/029a2b27cbdc27cf9d51d4a73ebeb503968849f6/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodQueue.java#L90"&gt;MediaPeriodQueue.java#L90&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;スレッド関連&lt;/h3&gt;
&lt;p&gt;新しい Thread, Looper, Handler が生成され保持される。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L271-L276"&gt;ExoPlayerImplInternal.java#L271-L276&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;一旦ここまでで ExoPlayerが生成された時の関連クラスは把握できた。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保持を目的とするPlaybackInfoUpdate・PlayerMessageInfo・MediaPeriodQueueの初期化を行う。&lt;/li&gt;
&lt;li&gt;Window/Periodを生成する。&lt;/li&gt;
&lt;li&gt;TrackSelectorを初期化する。&lt;/li&gt;
&lt;li&gt;RendererCapabilitiesの取得を行う。&lt;/li&gt;
&lt;li&gt;スレッドを生成する。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;明日は低遅延周りを理解したいため、 &lt;a href="./exoplayer_live_playback_speed_control.md"&gt;&lt;code&gt;LivePlaybackSpeedControl&lt;/code&gt; を深追いする。&lt;/a&gt;&lt;/p&gt;</content><category term="Android, ExoPlayer"></category></entry><entry><title>ExoPlayerが生成される時、具体的にはどんなクラスが生成されるのか</title><link href="/exoplayergasheng-cheng-sarerushi-ju-ti-de-nihadonnakurasugasheng-cheng-sarerunoka.html" rel="alternate"></link><published>2023-02-23T00:00:00+09:00</published><updated>2023-02-23T00:00:00+09:00</updated><author><name>dev-platong</name></author><id>tag:None,2023-02-23:/exoplayergasheng-cheng-sarerushi-ju-ti-de-nihadonnakurasugasheng-cheng-sarerunoka.html</id><summary type="html">&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;ExoPlayerでの再生問題におけるトラブルシューティング迅速化のため、再生に関わるクラスを把握する。&lt;br&gt;
今回はDefault実装 …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;ExoPlayerでの再生問題におけるトラブルシューティング迅速化のため、再生に関わるクラスを把握する。&lt;br&gt;
今回はDefault実装での ExoPlayer の生成時にどのようなクラスがインスタンス化され、それ以降に処理を委譲するために保持されているのか調査する。&lt;/p&gt;
&lt;h2&gt;環境&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ソフトウェア&lt;/th&gt;
&lt;th&gt;バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ExoPlayer&lt;/td&gt;
&lt;td&gt;&lt;a href="https://github.com/google/ExoPlayer/releases/tag/r2.16.1"&gt;r2.16.1&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;検証には &lt;code&gt;ExoPlayer.demo&lt;/code&gt; モジュールを利用する。&lt;/p&gt;
&lt;h2&gt;基礎知識&lt;/h2&gt;
&lt;p&gt;ExoPlayerではコンポーネントと呼ばれる一定の責務を持った塊がinterfaceとして存在し、各コンポーネントがDefault実装を持っているという構成を持っている。&lt;br&gt;
コンポーネントはインジェクトをサポートするので、サブコンポーネントにおける振る舞いをコンストラクタ経由でカスタムクラスを注入することで変更することができる。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayer.java#L102-L112"&gt;ExoPlayer.java#L102-L112&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;基本的にはよほど要件が複雑でない限りは、ライブラリが提供するDefault実装を使うことになるので、今回もDefault実装を使っていく。&lt;/p&gt;
&lt;h2&gt;ExoPlayerの生成&lt;/h2&gt;
&lt;p&gt;ExoPlayerインターフェース の実装である、 SimpleExoPlayerクラス が ExoPlayerインターフェースのbuilder から生成される。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayer.java#L967"&gt;ExoPlayer.java#L967&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;この時、 SimpleExoPlayerクラス では ExoPlayerImplクラスを生成し、playerフィールドに保持する。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java#L479"&gt;SimpleExoPlayer.java#L479&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;ExoPlayerImplインスタンスの生成時&lt;/h3&gt;
&lt;p&gt;Renderer・TrackSelector・MediaSourceFactory・LoadControl・BandwidthMeter・AnalyticsCollector・LivePlaybackSpeedControl・Clock・Playerなどが与えられる。&lt;br&gt;
各クラスの概要は以下にまとめるが、それぞれの詳細は追って記事にしていく。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java#L154"&gt;ExoPlayerImpl.java#L154&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;クラス名&lt;/th&gt;
&lt;th&gt;役割の概略&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Renderer&lt;/td&gt;
&lt;td&gt;SampleStreamコンポーネントからメディアを読み込む&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TrackSelector&lt;/td&gt;
&lt;td&gt;Rendererコンポーネントによって消費されるトラックを選択する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MediaSourceFactory&lt;/td&gt;
&lt;td&gt;MediaItemクラスからMediaSourceを生成する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LoadControl&lt;/td&gt;
&lt;td&gt;バッファリングをコントロールする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BandwidthMeter&lt;/td&gt;
&lt;td&gt;現在利用可能な帯域幅を推測する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AnalyticsCollector&lt;/td&gt;
&lt;td&gt;AnalyticsListenerコンポーネントにイベントを収集し送る&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LivePlaybackSpeedControl&lt;/td&gt;
&lt;td&gt;着実にターゲットライブオフセットを維持するために速度をコントロールする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Clock&lt;/td&gt;
&lt;td&gt;System Clockの抽象化と、HandlerWrapperコンポーネントの生成&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Player&lt;/td&gt;
&lt;td&gt;あるならばラップして使うためのPlayer&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;コンストラクタではdummyとなる値を生成し、最後に ExoPlayerInternalインスタンスを生成する。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java#L250"&gt;ExoPlayerImpl.java#L250&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ExoPlayerImplからExoPlayerImplInternalに渡される引数は、SimpleExoPlayerからExoPlayerImplに渡されるものとほとんど変わらない。&lt;br&gt;
このことからExoPlayerImplInternalは、ExoPlayerImplが内部的に保持するインスタンスの操作を担っていそうだということが推測できる。&lt;/p&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ExoPlayer.Builder -&amp;gt; SimpleExoPlayer -&amp;gt; ExoPlayerImpl -&amp;gt; ExoPlayerInternal と生成される。&lt;/li&gt;
&lt;li&gt;SimpleExoPlayerのコンストラクタの時点で生成し、引数としてコンストラクタに渡されたクラスの実際の操作をExoPlayerImplInternalが責務として持つ。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;明日は&lt;a href="./exoplayer_detail_of_exoplayerimplinternal.md"&gt;ExoPlayerImplInternalの生成時の振る舞いを掘り下げていく。&lt;/a&gt;&lt;/p&gt;</content><category term="Android, ExoPlayer"></category></entry><entry><title>ExoPlayerのRendererインターフェース</title><link href="/exoplayernorendererintahuesu.html" rel="alternate"></link><published>2022-03-09T00:00:00+09:00</published><updated>2022-03-09T00:00:00+09:00</updated><author><name>dev-platong</name></author><id>tag:None,2022-03-09:/exoplayernorendererintahuesu.html</id><summary type="html">&lt;h1&gt;Overview&lt;/h1&gt;
&lt;p&gt;満を辞してRendererを読みます。&lt;/p&gt;
&lt;h2&gt;責務&lt;/h2&gt;
&lt;p&gt;SampleStreamクラスからメディアをレンダリングします。&lt;br&gt;
内部的には ExoPlayer によってレンダラーの …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Overview&lt;/h1&gt;
&lt;p&gt;満を辞してRendererを読みます。&lt;/p&gt;
&lt;h2&gt;責務&lt;/h2&gt;
&lt;p&gt;SampleStreamクラスからメディアをレンダリングします。&lt;br&gt;
内部的には ExoPlayer によってレンダラーのライフサイクルは管理されます。&lt;br&gt;
レンダラーは可能なトラック変更と全ての再生状態のような様々なステートに移行します。&lt;/p&gt;
&lt;h2&gt;WakeUpLisener&lt;/h2&gt;
&lt;p&gt;いくつかのレンダラーは &lt;code&gt;render()&lt;/code&gt; メソッドが呼ばれるべき時を通知します。&lt;br&gt;
これはプレイヤーが次にウェイクアップするまでスリープすることを可能にします（タイトループの中で &lt;code&gt;render()&lt;/code&gt; メソッドを呼ぶ代わりです）。&lt;br&gt;
割り込みベースのスケジューリングの目的は、電力消費を抑えることにあります。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;void onSleep(long wakeupDeadlineMs)&lt;/li&gt;
&lt;li&gt;void onWakeup()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.17.0/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FRenderer.java#L59-L78"&gt;Renderer.java#L59-L78&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;MessageType&lt;/h2&gt;
&lt;p&gt;レンダラーに渡すことができるメッセージのタイプを示します。アプリケーション定義の値を &lt;code&gt;MSG_CUSTOM_BASE&lt;/code&gt; を使って持てることに注意。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;VIDEO_OUTPUT&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ExoPlayer.createMesssage()&lt;/code&gt; を通じてビデオレンダラに渡されるメッセージ。&lt;br&gt;
payloadはSurfaceであることが通常だが、いくつのビデオレンダラーは他の &lt;code&gt;VideoDecoderOutputBufferRenderer&lt;/code&gt; などにも出力できる。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;VOLUME&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ExoPlayer.createMesssage()&lt;/code&gt; を通じてオーディオレンダラに渡されるメッセージ。&lt;br&gt;
payloadは0~1のFloat。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AUDIO_ATTRIBUTES&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ExoPlayer.createMesssage()&lt;/code&gt; を通じてオーディオレンダラに渡されるメッセージ。  &lt;br&gt;
payloadはオーディオトラックに設定されることになる &lt;code&gt;AudioAttributes&lt;/code&gt; クラスのインスタンスであるべき。 何も設定されなければ、一般的なメディア再生に向いているデフォルトが使われる。&lt;br&gt;
再生中の設定がオーディオトラックを再生成することで短いオーディオギャップを生む可能性があります。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SCALING_MODE&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ExoPlayer.createMesssage()&lt;/code&gt; を通じてMediaCodecベースのビデオレンダラに渡されるメッセージ。payloadは &lt;code&gt;C.VideoScalingMode&lt;/code&gt; の1つである必要があります。&lt;br&gt;
Scalingモードは &lt;code&gt;android.view.SurfaceView&lt;/code&gt; によってターゲットレンダラーが所有されている時のみ利用可能です。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CHANGE_FRAME_RATE_STRATEGY&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ExoPlayer.createMesssage()&lt;/code&gt; を通じてビデオレンダラに渡されるメッセージ。&lt;br&gt;
payloadは&lt;code&gt;C.VideoChangeFrameRateStrategy&lt;/code&gt; の1つである必要があります。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AUX_EFFECT_INFO&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ExoPlayer.createMesssage()&lt;/code&gt; を通じてオーディオレンダラに渡されるメッセージ。  &lt;br&gt;
補助オーディオエフェクトを意味する &lt;code&gt;AuxEffectInfo&lt;/code&gt; がpayloadになるべきです。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;VIDEO_FRAME_METADATA_LISTEN&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ExoPlayer.createMesssage()&lt;/code&gt; を通じてビデオレンダラに渡されるメッセージ。&lt;br&gt;
&lt;code&gt;VideoFrameMetadataListener&lt;/code&gt; インスタンスがpayloadであるべき。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CAMERA_MOTION_LISTENER&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ExoPlayer.createMesssage()&lt;/code&gt; を通じてカメラモーションレンダラに渡されるメッセージ。&lt;br&gt;
&lt;code&gt;CameraMotionListener&lt;/code&gt; がpayloadであるべき。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SKIP_SILENCE_ENABLED&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ExoPlayer.createMesssage()&lt;/code&gt; を通じてオーディオレンダラに渡されるメッセージ。  &lt;br&gt;
無音をスキップするか否かをpayloadに渡します。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AUDIO_SESSION_ID&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ExoPlayer.createMesssage()&lt;/code&gt; を通じてビデオレンダラとオーディオレンダラに渡されるメッセージ。&lt;br&gt;
payloadはオーディオセッションIDを表すintで、下のオーディオトラックにアタッチされるもので、ビデオレンダラがトンネリングをサポートするなれば、オーディオセッションIDを利用します。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;WAKEUP_LISTENER&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ExoPlayer.createMesssage()&lt;/code&gt; を通じて &lt;code&gt;Renderer&lt;/code&gt; インターフェースに渡されるメッセージ。&lt;br&gt;
レンダラーが他のコンポーネントのウェイクアップが可能なことを知らせます。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.17.0/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FRenderer.java#L80-L204"&gt;Renderer.java#L80-L204&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;State&lt;/h2&gt;
&lt;p&gt;&lt;img src="https://exoplayer.dev/doc/reference/com/google/android/exoplayer2/doc-files/renderer-states.svg"/&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;DISABLED&lt;/p&gt;
&lt;p&gt;レンダラーが利用不可。メディアデコーダなどのレンダリングに必要なものを得ていません。もしかしたら継続的に利用可能なものを持っているかもしれません。&lt;br&gt;
&lt;code&gt;reset()&lt;/code&gt; を呼ぶことで強制的にそういった保持しているリソースを強制解放できます。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ENABLED&lt;/p&gt;
&lt;p&gt;レンダラーが利用可能だが始まってはいません。このステートは、初めのビデオフレームのような現在のポジションのメディアをレンダリングしているかもしれません。&lt;br&gt;
ですがポジションが先に進むことはありません。メディアデコーダなどのレンダリングに必要なリソースを保持していると考えるのが一般的なこのステートへの考え方です。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;STARTED&lt;/p&gt;
&lt;p&gt;レンダラーが始まっています。 &lt;code&gt;renderer()&lt;/code&gt; メソッドを飛ぶことでメディアのレンダーが始まります。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.17.0/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FRenderer.java#L206-L231"&gt;Renderer.java#L206-L231&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;getter&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;String getName()&lt;/code&gt;：ロギングやデバッグの目的のもので、レンダラーの名前を返します。レンダラーのクラスネームであることが一般的です。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@C.TrackType int getTrackType()&lt;/code&gt;：レンダラーがハンドリングしているトラックタイプを返します。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RendererCapabilities getCapabilities()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int getState()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;MediaClock getMediaClock()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;もしレンダラーが自身の再生ポジションを越える場合にこのメソッドが対応するMediaClockを返します。もし MediaClockが帰ったならばプレイヤーはそのMediaClockを使います。&lt;br&gt;
プレイヤーはこのメソッドから返された最低一つのレンダラーを持っているかもしれません。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;@Nullable SampleStream getStream()&lt;/code&gt;：もしレンダラーがdisabledならばnullが帰ります。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;long getReadingPositionUs()&lt;/code&gt;：rendererが読み込んだサンプルの時間を返します。 &lt;code&gt;STATE_ENABLED&lt;/code&gt; または &lt;code&gt;STATE_STARTED&lt;/code&gt; の時に呼ばれます。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boolean isCurrentStreamFinal()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;boolean hasReadStreamToEnd()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;このメソッドは &lt;code&gt;STATE_ENABLED&lt;/code&gt; または &lt;code&gt;STATE_STARTED&lt;/code&gt; の時に呼ばれます。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;boolean isEnded()&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;メソッド&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;void init(int index, PlayerId playerId)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;プレイヤーが再生に使おうとしているレンダラーが初期化されます。indexはプレイヤーの中のレンダラーインデックスでPlayerIdはプレイヤーのIDです。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;void enable(RendererConfiguration configuration, Format[] formats, SampleStream stream, long positonUs, boolean joining, boolean mayRendererStartOfStream, long startPositionUs, long offsetUs)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;レンダラーに指定した SampleStreamを消費することを可能にします。このメソッドはレンダラーが &lt;code&gt;STATE_DISABLED&lt;/code&gt; の時に呼ばれる可能性があります。
- format：利用可能なフォーマット
- positionUs：プレイヤーの現在のポジション
- joining：レンダラーを再生中のものに合流するかどうか
- mayRendererStartOfStream：レンダラーが &lt;code&gt;STATE_STARTED&lt;/code&gt; 出なくてもレンダラーがストリームを開始することを許可するかどうか
- startPositionUs：レンダラーの中の時間でのストリームの開始ポジション
- offsetUs： SampleStreamから読み込まれたバッファのタイムスタンプにレンダリング前に追加されるオフセットを指定します。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;void start()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;レンダラーを開始します。&lt;code&gt;render()&lt;/code&gt; を呼ぶことががレンダリングを開始することを意味しています。 &lt;code&gt;STATE_ENABLED&lt;/code&gt; の場合に呼ばれます。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;void replaceStream(Format[] formats, SampleStream stream, long startPositionUs, long offsetUs)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;SampleStreamを交換します。 &lt;code&gt;STATE_ENABLED&lt;/code&gt; と &lt;code&gt;STATE_STARTED&lt;/code&gt; の場合に呼ばれます。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;void setCurrentStreamFinal()&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;void maybeThrowStreamError() throws IOException&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;void resetPosition(long positionUs)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;PositionDiscontinuityが発生したことをレンダラーに知らせます。レンダラーのサンプルストリームはキーフレームから再生をすることを保証します。&lt;br&gt;
&lt;code&gt;STATE_ENABLED&lt;/code&gt; と &lt;code&gt;STATE_STARTED&lt;/code&gt; の場合に呼ばれます。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;default void setPlaybackSpeed(float currentPlaybackSpeed, float targetPlaybackSpeed)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;targetPlaybackSpeedは currentPlaybackSpeedとは異なります。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackException&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;SampleStreamをインクリメンタルにレンダリングします。&lt;br&gt;
レンダラーが{@link #STATE_ENABLED}の状態であれば、このメソッドを呼び出すたびにンダラーを起動したときに SampleStream をレンダリングできるようにするための作業を行います。もし レンダラーが STATE_STARTED の状態であれば、このメソッドを呼び出すと 指定されたメディアポジションに同期してSampleStreamを表示します。&lt;/p&gt;
&lt;p&gt;The renderer may also render the very start of the media at the current position (e.g. the
first frame of a video stream) while still in the {@link #STATE_ENABLED} state, unless it's the
initial start of the media after calling {@link #enable(RendererConfiguration, Format[],
SampleStream, long, boolean, boolean, long, long)} with {@code mayRenderStartOfStream} set to
{@code false}. （あまりにも長くて翻訳がだるい、DEEPLもダメだし。）&lt;/p&gt;
&lt;p&gt;このメソッドはすぐに返されるべきです。
&lt;code&gt;STATE_ENABLED&lt;/code&gt; と &lt;code&gt;STATE_STARTED&lt;/code&gt; の場合に呼ばれます。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;boolean isReady()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;If the renderer is in the {@link #STATE_STARTED} state then returning true indicates that
the renderer has everything that it needs to continue playback. Returning false indicates that
the player should pause until the renderer is ready.&lt;/p&gt;
&lt;p&gt;If the renderer is in the {@link #STATE_ENABLED} state then returning true indicates that
the renderer is ready for playback to be started. Returning false indicates that it is not.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;STATE_ENABLED&lt;/code&gt; と &lt;code&gt;STATE_STARTED&lt;/code&gt; の場合に呼ばれます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;void stop()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;STATE_ENABLED&lt;/code&gt;へ移行します
&lt;code&gt;STATE_STARTED&lt;/code&gt; の場合に呼ばれます。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;void disabled()&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;STATE_ENABLED&lt;/code&gt; の場合に呼ばれます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;reset()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;STATE_DISABLED&lt;/code&gt;の場合に呼ばれます。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;まとめ&lt;/h1&gt;
&lt;p&gt;render()メソッドの実実装と、getMediaClock()の実際の振る舞いが気になった。&lt;br&gt;
例えば音ズレの問題は &lt;code&gt;getMediaClock()&lt;/code&gt; が正しく振る舞えば起きないような気がする。&lt;/p&gt;
&lt;p&gt;長すぎて後半だるかった。&lt;/p&gt;</content><category term="Android, ExoPlayer"></category></entry></feed>