<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>dev-platong's home</title><link href="/" rel="alternate"></link><link href="/feeds/all.atom.xml" rel="self"></link><id>/</id><updated>2023-03-10T00:00:00+09:00</updated><entry><title>ExoPlayerのLoaderファイナルクラス</title><link href="/exoplayernoloaderhuainarukurasu.html" rel="alternate"></link><published>2023-03-10T00:00:00+09:00</published><updated>2023-03-10T00:00:00+09:00</updated><author><name>dev-platong</name></author><id>tag:None,2023-03-10:/exoplayernoloaderhuainarukurasu.html</id><summary type="html">&lt;h1&gt;Overview&lt;/h1&gt;
&lt;p&gt;HlsSampleStreamWrapperを見ていたら、出てきたので軽めに触れる。&lt;/p&gt;
&lt;h2&gt;責務&lt;/h2&gt;
&lt;p&gt;Loadableインターフェースを持つもののバックグラウンドでの管理。&lt;/p&gt;
&lt;h2&gt;基 …&lt;/h2&gt;</summary><content type="html">&lt;h1&gt;Overview&lt;/h1&gt;
&lt;p&gt;HlsSampleStreamWrapperを見ていたら、出てきたので軽めに触れる。&lt;/p&gt;
&lt;h2&gt;責務&lt;/h2&gt;
&lt;p&gt;Loadableインターフェースを持つもののバックグラウンドでの管理。&lt;/p&gt;
&lt;h2&gt;基底&lt;/h2&gt;
&lt;p&gt;LoaderErrorThrower：条件によって例外をスローするか判断する &lt;code&gt;maybeThrowError()&lt;/code&gt;を持つ。&lt;/p&gt;
&lt;h2&gt;空間&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;upstream&lt;/code&gt; 空間&lt;/p&gt;
&lt;h1&gt;定義クラス・例外・インターフェース&lt;/h1&gt;
&lt;h2&gt;例外：UnexpectedLoaderException&lt;/h2&gt;
&lt;p&gt;IOExceptionの拡張。特別な機能は持たない。&lt;/p&gt;
&lt;h1&gt;インターフェース：Loadable&lt;/h1&gt;
&lt;h2&gt;責務&lt;/h2&gt;
&lt;p&gt;Loaderによってloadされるオブジェクト&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cancelLoad()&lt;/code&gt; メソッドと &lt;code&gt;load()&lt;/code&gt; メソッドを持つ。&lt;/p&gt;
&lt;h2&gt;インターフェース；Callback(T extends Loadable)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;void onLoadCompleted(T loadable, long elapsedRealtimeMs, long loadDurationMs)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void onLoadCancled(T loadable, long elapsedRealtimeMs, long loadDurationMs, boolean released)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LoadErrorAction onLoadError(T loadable, long elapsedRealtimeMs, long loadDurationMs, IOException error, int errorCount)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="ExoPlayer"></category></entry><entry><title>ExoPlayerのBufferクラス</title><link href="/exoplayernobufferkurasu.html" rel="alternate"></link><published>2023-03-09T00:00:00+09:00</published><updated>2023-03-09T00:00:00+09:00</updated><author><name>dev-platong</name></author><id>tag:None,2023-03-09:/exoplayernobufferkurasu.html</id><summary type="html">&lt;h1&gt;Overview&lt;/h1&gt;
&lt;p&gt;SampleStreamに渡されるDecoderInputBufferを掘っていく途中で基底となるBuffer抽象クラスを見ます。&lt;/p&gt;
&lt;h1&gt;責務&lt;/h1&gt;
&lt;p&gt;バッファとフラグの基底クラス。&lt;/p&gt;
&lt;h2&gt;フラ …&lt;/h2&gt;</summary><content type="html">&lt;h1&gt;Overview&lt;/h1&gt;
&lt;p&gt;SampleStreamに渡されるDecoderInputBufferを掘っていく途中で基底となるBuffer抽象クラスを見ます。&lt;/p&gt;
&lt;h1&gt;責務&lt;/h1&gt;
&lt;p&gt;バッファとフラグの基底クラス。&lt;/p&gt;
&lt;h2&gt;フラグの6種類&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;KEY_FRAME：バッファが同期サンプルを持っていることを示す。&lt;/li&gt;
&lt;li&gt;END_OF_STREAM：EOSのシグナルとなるからのバッファであることを示す。&lt;/li&gt;
&lt;li&gt;HAS_SUPPLEMENTAL_DATA：バッファが補完的なデータを持っていることを示す。&lt;/li&gt;
&lt;li&gt;LAST_SAMPLE：ストリームの最後のメディアサンプルであることを知られているものを含んでいることを示す。&lt;/li&gt;
&lt;li&gt;ENCRYPTED：バッファが一部または全て暗号化されている。&lt;/li&gt;
&lt;li&gt;DECODE_ONLY：レンダリングされないものを示す。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.17.0/library%2Fcommon%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FC.java#L480-L510"&gt;C.java#L480-L510&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.17.0/library/decoder/src/main/java/com/google/android/exoplayer2/decoder/Buffer.java"&gt;Buffer.java&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;振る舞い&lt;/h2&gt;
&lt;p&gt;Bufferクラスでは主にフラグの扱いを定義している。&lt;br&gt;
持っているフラグから、 &lt;code&gt;isDecodeOnly&lt;/code&gt; かなどを判定しているだけ。&lt;br&gt;
フラグはset/add/clearできる。&lt;/p&gt;
&lt;h1&gt;まとめ&lt;/h1&gt;
&lt;p&gt;フラグについての振る舞いしか定義されていない。フラグは6つある。&lt;/p&gt;</content><category term="ExoPlayer"></category></entry><entry><title>ExoPlayerのDecoderInputBufferクラス</title><link href="/exoplayernodecoderinputbufferkurasu.html" rel="alternate"></link><published>2023-03-09T00:00:00+09:00</published><updated>2023-03-09T00:00:00+09:00</updated><author><name>dev-platong</name></author><id>tag:None,2023-03-09:/exoplayernodecoderinputbufferkurasu.html</id><summary type="html">&lt;h1&gt;Overview&lt;/h1&gt;
&lt;p&gt;SampleStreamで &lt;code&gt;readData()&lt;/code&gt; 時に渡される &lt;code&gt;DecoderInputBuffer&lt;/code&gt; クラスについて調べる。&lt;/p&gt;
&lt;h2&gt;責務&lt;/h2&gt;
&lt;p&gt;デコーダへの入力を保持します。  &lt;/p&gt;
&lt;h2&gt;基底&lt;/h2&gt;
&lt;p&gt;[Buffer抽象クラス]{filename}./exoplayer_buffer.md)&lt;/p&gt;
&lt;h2&gt;@BufferReplacementMode …&lt;/h2&gt;</summary><content type="html">&lt;h1&gt;Overview&lt;/h1&gt;
&lt;p&gt;SampleStreamで &lt;code&gt;readData()&lt;/code&gt; 時に渡される &lt;code&gt;DecoderInputBuffer&lt;/code&gt; クラスについて調べる。&lt;/p&gt;
&lt;h2&gt;責務&lt;/h2&gt;
&lt;p&gt;デコーダへの入力を保持します。  &lt;/p&gt;
&lt;h2&gt;基底&lt;/h2&gt;
&lt;p&gt;[Buffer抽象クラス]{filename}./exoplayer_buffer.md)&lt;/p&gt;
&lt;h2&gt;@BufferReplacementMode&lt;/h2&gt;
&lt;p&gt;既存のバッファのキャパシティが十分でない場合に&lt;code&gt;ensureSpaceForWrite&lt;/code&gt; でどのように置換バッファを生成するかをコントロールします。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BUFFER_REPLACEMENT_MODE_DISABLED&lt;/li&gt;
&lt;li&gt;BUFFER_REPLACEMENT_MODE_NORMAL： &lt;code&gt;ByteBuffer.allocate(int)&lt;/code&gt;を用いたバッファ置換を許容します。&lt;/li&gt;
&lt;li&gt;BUFFER_REPLACEMENT_MODE_DIRECT： &lt;code&gt;ByteBuffer.allocateDirect(int)&lt;/code&gt; を用いたバッファ置換を許容します。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;InsufficientCapacityExceptionファイナルクラス&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;BUFFER_REPLACEMENT_MODE_DISABLED&lt;/code&gt; または 十分なキャパシティを持っていない場合の DocoderInputBufferへの書き込み時にスローします。&lt;/p&gt;
&lt;h2&gt;保持するByteBuffer&lt;/h2&gt;
&lt;p&gt;dataフィールドにデータを持つことはもちろんですが、supplementalDataを持つ可能性もあります。&lt;br&gt;
バッファは補完データを持つ場合にはポジション0からそのリミットまでバッファが入力されます。&lt;/p&gt;
&lt;h2&gt;その他関連クラス&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Format&lt;/li&gt;
&lt;li&gt;CryptInfo&lt;/li&gt;
&lt;li&gt;Nullable ByteBuffer&lt;/li&gt;
&lt;/ul&gt;</content><category term="ExoPlayer"></category></entry><entry><title>ExoPlayerのFormatクラス</title><link href="/exoplayernoformatkurasu.html" rel="alternate"></link><published>2023-03-09T00:00:00+09:00</published><updated>2023-03-09T00:00:00+09:00</updated><author><name>dev-platong</name></author><id>tag:None,2023-03-09:/exoplayernoformatkurasu.html</id><summary type="html">&lt;h1&gt;概要&lt;/h1&gt;
&lt;p&gt;SampleStreamがreadData()する際に渡される FormatHolder から掘り下げます。&lt;/p&gt;
&lt;h2&gt;責務&lt;/h2&gt;
&lt;p&gt;メディアフォーマットを表現します。finalクラスです。&lt;/p&gt;
&lt;h3&gt;全てのフ …&lt;/h3&gt;</summary><content type="html">&lt;h1&gt;概要&lt;/h1&gt;
&lt;p&gt;SampleStreamがreadData()する際に渡される FormatHolder から掘り下げます。&lt;/p&gt;
&lt;h2&gt;責務&lt;/h2&gt;
&lt;p&gt;メディアフォーマットを表現します。finalクラスです。&lt;/p&gt;
&lt;h3&gt;全てのフォーマットに共通する8つのフィールド&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;id（Nullable String）&lt;/li&gt;
&lt;li&gt;label&lt;/li&gt;
&lt;li&gt;language&lt;/li&gt;
&lt;li&gt;selectionFlags&lt;/li&gt;
&lt;li&gt;roleFlags&lt;/li&gt;
&lt;li&gt;averageBitrate&lt;/li&gt;
&lt;li&gt;codecs&lt;/li&gt;
&lt;li&gt;metadata&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;コンテナフォーマットに共通するフィールド&lt;/h3&gt;
&lt;p&gt;コンテナMIME TYPEを持つ場合。&lt;br&gt;
コンテナが単一のメディアトラックしか含まない場合は、後述のサンプルフォーマットと同じになります。&lt;/p&gt;
&lt;h3&gt;サンプルフォーマットに共通するフィールド&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;sampleMimeType&lt;/li&gt;
&lt;li&gt;maxInputsize&lt;/li&gt;
&lt;li&gt;initializationData&lt;/li&gt;
&lt;li&gt;drmInitData&lt;/li&gt;
&lt;li&gt;subsampleOffsetUs&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;ビデオフォーマットに共通するフィールド&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;width&lt;/li&gt;
&lt;li&gt;height&lt;/li&gt;
&lt;li&gt;frameRate&lt;/li&gt;
&lt;li&gt;rotationDegrees&lt;/li&gt;
&lt;li&gt;pixelWidthHeightRatio&lt;/li&gt;
&lt;li&gt;projectionData&lt;/li&gt;
&lt;li&gt;stereoMode&lt;/li&gt;
&lt;li&gt;colorInfo&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;音声フォーマットに共通するフィールド&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;channelCount&lt;/li&gt;
&lt;li&gt;sampleRate&lt;/li&gt;
&lt;li&gt;pcmEncoding&lt;/li&gt;
&lt;li&gt;encoderDelay&lt;/li&gt;
&lt;li&gt;encoderPadding&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;テキストフォーマットに共通するフィールド&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;accessibilityChannel&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;メソッドなど&lt;/h1&gt;
&lt;p&gt;getter/setterの他に、copyや音声サンプルフォーマットなどを想定した &lt;code&gt;createAudioSampleFormat()&lt;/code&gt; などがありますが、基本的にはデータの塊と捉えていいのではない得ていいのでは。&lt;/p&gt;
&lt;p&gt;https://github.com/google/ExoPlayer/blob/r2.17.0/library%2Fcommon%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FFormat.java&lt;/p&gt;</content><category term="ExoPlayer"></category></entry><entry><title>ExoPlayerのHlsSampleStreamファイナルクラス</title><link href="/exoplayernohlssamplestreamhuainarukurasu.html" rel="alternate"></link><published>2023-03-07T00:00:00+09:00</published><updated>2023-03-07T00:00:00+09:00</updated><author><name>dev-platong</name></author><id>tag:None,2023-03-07:/exoplayernohlssamplestreamhuainarukurasu.html</id><summary type="html">&lt;h1&gt;Overview&lt;/h1&gt;
&lt;p&gt;SampleStreamを読んだので、その実装クラスを見ていきます。&lt;/p&gt;
&lt;h1&gt;責務&lt;/h1&gt;
&lt;p&gt;HLSの中の特定のサンプルキューを表現します。&lt;/p&gt;
&lt;h1&gt;HlsSampleStreamWrapperファイナル …&lt;/h1&gt;</summary><content type="html">&lt;h1&gt;Overview&lt;/h1&gt;
&lt;p&gt;SampleStreamを読んだので、その実装クラスを見ていきます。&lt;/p&gt;
&lt;h1&gt;責務&lt;/h1&gt;
&lt;p&gt;HLSの中の特定のサンプルキューを表現します。&lt;/p&gt;
&lt;h1&gt;HlsSampleStreamWrapperファイナルクラス&lt;/h1&gt;
&lt;p&gt;こちらが本体といってもいいほど巨大なクラスです。&lt;/p&gt;</content><category term="ExoPlayer"></category></entry><entry><title>ExoPlayerのSampleStreamインターフェース</title><link href="/exoplayernosamplestreamintahuesu.html" rel="alternate"></link><published>2023-03-07T00:00:00+09:00</published><updated>2023-03-07T00:00:00+09:00</updated><author><name>dev-platong</name></author><id>tag:None,2023-03-07:/exoplayernosamplestreamintahuesu.html</id><summary type="html">&lt;h1&gt;概要&lt;/h1&gt;
&lt;p&gt;Rendererインターフェースによる動画データの描画の挙動を追っていく過程です。&lt;br&gt;
Rendererがデータを読み込んでいるSampleStreamに …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;概要&lt;/h1&gt;
&lt;p&gt;Rendererインターフェースによる動画データの描画の挙動を追っていく過程です。&lt;br&gt;
Rendererがデータを読み込んでいるSampleStreamについて触れます。&lt;/p&gt;
&lt;h2&gt;SampleStreamインターフェースの責務&lt;/h2&gt;
&lt;p&gt;フォーマット情報が紐づいたメディアサンプルのストリームを表現します。&lt;/p&gt;
&lt;h2&gt;空間&lt;/h2&gt;
&lt;p&gt;sourceパッケージです（&lt;code&gt;com.google.android.exoplayer2.source&lt;/code&gt;）。&lt;/p&gt;
&lt;h2&gt;4つのメソッド&lt;/h2&gt;
&lt;h3&gt;boolean isReady()&lt;/h3&gt;
&lt;p&gt;読み込み可能なデータが利用できるかを返します。&lt;br&gt;
EOSは常にreadyであることに注意します。&lt;/p&gt;
&lt;h3&gt;void maybeThrowError() throws IOException&lt;/h3&gt;
&lt;p&gt;読み込み時にデータが阻害された場合エラーを吐きます。&lt;/p&gt;
&lt;h3&gt;@ReadDataResult int readData(FormatHolder formatHolder, DecoderInputBuffer buffer, @ReadFlags int readFlags)&lt;/h3&gt;
&lt;h4&gt;@ReadDataResult&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;RESULT_NOTHING_READ&lt;/code&gt; または &lt;code&gt;RESULT_FORMAT_READ&lt;/code&gt;・ &lt;code&gt;RESULT_BUFFER_READ&lt;/code&gt;が帰ります。&lt;br&gt;
何も読めなかったか、フォーマットかバッファーかです。&lt;/p&gt;
&lt;h4&gt;FormatHolderファイナルクラス&lt;/h4&gt;
&lt;p&gt;FormatクラスとDrmSessionクラスを保持します。&lt;/p&gt;
&lt;h5&gt;Formatファイナルクラス&lt;/h5&gt;
&lt;p&gt;&lt;a href="/exoplayernoformatkurasu.html"&gt;記事&lt;/a&gt;をご覧ください。&lt;/p&gt;
&lt;h4&gt;DecoderInputBuffer&lt;/h4&gt;
&lt;p&gt;&lt;a href="/exoplayernodecoderinputbufferkurasu.html"&gt;記事&lt;/a&gt;をご覧ください。&lt;/p&gt;
&lt;h4&gt;ReadFlags&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;FLAG_PEEK：サンプルバッファが読み込まれる時、読み込みポジションは先に進むべきでは無いことを示します。&lt;/li&gt;
&lt;li&gt;FLAG_REQUIRE_FORMAT：次にバッファが読まれるときに、サンプルのフォーマットを代わりに読みます。&lt;/li&gt;
&lt;li&gt;FLAG_OMIT_SAMPLE_DATA： &lt;code&gt;{@link DecoderInputBuffer#data}, {@link DecoderInputBuffer#supplementalData} と {@link DecoderInputBuffer#cryptoInfo}&lt;/code&gt;を呼ぶ必要がないことを伝えます。効率的なサンプルメタデータのピーキングや、サンプルバッファのスキップに利用されます。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;int skipData（long positionUs）&lt;/h3&gt;
&lt;p&gt;特定のポジション以前のキーフレームをスキップすることを試みます。または、&lt;code&gt;positionUs&lt;/code&gt; が EOS(End of stream)を超えている場合、データをスキップします。&lt;/p&gt;
&lt;h1&gt;まとめ&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;4つのメソッドがある。&lt;/li&gt;
&lt;li&gt;読み込む・スキップする・準備可能・エラーをスローする。&lt;/li&gt;
&lt;li&gt;DocoderInputBufferとFormatHolderが関係する。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;明日はFormatクラスについて扱います。&lt;/p&gt;</content><category term="ExoPlayer"></category></entry><entry><title>ExoPlayerのSequenceableLoaderインターフェース</title><link href="/exoplayernosequenceableloaderintahuesu.html" rel="alternate"></link><published>2023-03-07T00:00:00+09:00</published><updated>2023-03-07T00:00:00+09:00</updated><author><name>dev-platong</name></author><id>tag:None,2023-03-07:/exoplayernosequenceableloaderintahuesu.html</id><summary type="html">&lt;h1&gt;Overview&lt;/h1&gt;
&lt;p&gt;HlsSampleWrapperがimplementsしているので。&lt;/p&gt;
&lt;h2&gt;責務&lt;/h2&gt;
&lt;p&gt;他のローダーと同期的に進行可能なローダー。&lt;/p&gt;
&lt;h2&gt;基底&lt;/h2&gt;
&lt;p&gt;なし&lt;/p&gt;
&lt;h2&gt;空間&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;source&lt;/code&gt;&lt;/p&gt;
&lt;h1&gt;インターフェース&lt;/h1&gt;
&lt;h2&gt;Callback&lt;T extends SequencableLoader&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;void onContinueLoadingRequested …&lt;/code&gt;&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Overview&lt;/h1&gt;
&lt;p&gt;HlsSampleWrapperがimplementsしているので。&lt;/p&gt;
&lt;h2&gt;責務&lt;/h2&gt;
&lt;p&gt;他のローダーと同期的に進行可能なローダー。&lt;/p&gt;
&lt;h2&gt;基底&lt;/h2&gt;
&lt;p&gt;なし&lt;/p&gt;
&lt;h2&gt;空間&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;source&lt;/code&gt;&lt;/p&gt;
&lt;h1&gt;インターフェース&lt;/h1&gt;
&lt;h2&gt;Callback&lt;T extends SequencableLoader&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;void onContinueLoadingRequested(T source)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;continueLoading(long)&lt;/code&gt;を呼ぶことを期待するコールバック。再生スレッドから呼ばれる。 &lt;/p&gt;
&lt;h2&gt;メソッド&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;long getBufferedPositionUs()&lt;/code&gt;・&lt;code&gt;long getNextLoadPositionUs()&lt;/code&gt;はそのまま。&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;boolean continueLoading(long positionUs)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;継続的なローディングを試みます。&lt;code&gt;True&lt;/code&gt;を返す場合には進行が得られたことを示し、 &lt;code&gt;getNextLoadPosition()&lt;/code&gt; の値が呼び出し前と変わることを意味します。&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;boolean isLoading()&lt;/code&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;code&gt;void reevaluateBuffer(long positionUs)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;異なる品質に変わったならばリバッファリングします。&lt;/p&gt;</content><category term="ExoPlayer"></category></entry><entry><title>ExoPlayerのsetMediaItemを読んだ時</title><link href="/exoplayernosetmediaitemwodu-ndashi.html" rel="alternate"></link><published>2023-02-28T00:00:00+09:00</published><updated>2023-02-28T00:00:00+09:00</updated><author><name>dev-platong</name></author><id>tag:None,2023-02-28:/exoplayernosetmediaitemwodu-ndashi.html</id><summary type="html">&lt;h2&gt;ExoPlayer.setMediaItemを呼びます。&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ExoPlayerImpl.setMediaSourcesInternal()&lt;/code&gt; が呼ばれます。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java#L1529"&gt;exoplayer2/ExoPlayerImpl.java#L1529&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;仰々しいですが、やっていることは &lt;code&gt;internalPlayer.setMediaSources()&lt;/code&gt; を呼び、 &lt;code&gt;updatePlaybackInfo()&lt;/code&gt; を呼びます。&lt;/p&gt;
&lt;h2&gt;ExoPlayerImplInternal.setMediaSources()&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;MSG_SET_MEDIA_SOURCES …&lt;/code&gt;&lt;/p&gt;</summary><content type="html">&lt;h2&gt;ExoPlayer.setMediaItemを呼びます。&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ExoPlayerImpl.setMediaSourcesInternal()&lt;/code&gt; が呼ばれます。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java#L1529"&gt;exoplayer2/ExoPlayerImpl.java#L1529&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;仰々しいですが、やっていることは &lt;code&gt;internalPlayer.setMediaSources()&lt;/code&gt; を呼び、 &lt;code&gt;updatePlaybackInfo()&lt;/code&gt; を呼びます。&lt;/p&gt;
&lt;h2&gt;ExoPlayerImplInternal.setMediaSources()&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;MSG_SET_MEDIA_SOURCES&lt;/code&gt; を Targetに送ります。そして自身の &lt;code&gt;setMediaItemsInternal()&lt;/code&gt; を呼びます。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L522-L523"&gt;ExoPlayerImplInternal.java#L522-L523&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/029a2b27cbdc27cf9d51d4a73ebeb503968849f6/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L692"&gt;ExoPlayerImplInternal.java#L692&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最終的に&lt;code&gt;handleMediaSourceListInfoRefreshed()&lt;/code&gt;が呼ばれます。このメソッドは長すぎるので明日。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/029a2b27cbdc27cf9d51d4a73ebeb503968849f6/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L1793"&gt;ExoPlayerImplInternal.java#L1793&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;private ExoPlayerImplInternal.handleMediaSourceListInfoRefreshed(Timeline timeline, boolean isSourceRefresh)&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L1793"&gt;ExoPlayerImplInternal.java#L1793&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;resolvePositionForPlaylistChange(Timeline timeline, PlaybackInfo playbackInfo, @Nullable SeekPosition pendingInitialSeekPosition, MediaPeriodQueue queue, @RepeatMode int repeatMode, boolean shuffleModeEnabled, Timeline.Window window, Timeline.Period period)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L2508"&gt;ExoPlayerImplInternal.java#L2508&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;SeekPosition&lt;/h4&gt;
&lt;p&gt;データクラスです（&lt;code&gt;private static final class&lt;/code&gt; ）。&lt;br&gt;
&lt;code&gt;Timeline&lt;/code&gt;・&lt;code&gt;int windowIndex&lt;/code&gt;・&lt;code&gt;long windowPositionUs&lt;/code&gt; を持ちます。これにより &lt;strong&gt;シークにはPeriodという概念が関係ない（windowとwindow内の位置が決まればいい）&lt;/strong&gt; ということがわかります。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/029a2b27cbdc27cf9d51d4a73ebeb503968849f6/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L2922"&gt;ExoPlayerImplInternal.java#L2922&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;特徴的なのは、まず &lt;code&gt;Timeline&lt;/code&gt; に関して。 位置の特定が必要な場合には、 &lt;code&gt;Timeline&lt;/code&gt; ・ &lt;code&gt;Timeline.Window&lt;/code&gt;・ &lt;code&gt;Timeline・Period&lt;/code&gt; が渡されます。&lt;br&gt;
そして &lt;code&gt;Timeline&lt;/code&gt; は empty の場合があることにも注意しなければなりません。SEE：&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L2517"&gt;ExoPlayerImplInternal.java#L2517&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;次に、 MediaPeriodIdとPeriodUidの扱いです。MediaPeriodIdは &lt;code&gt;old&lt;/code&gt; なのに対し、 &lt;code&gt;PeriodUid&lt;/code&gt; に関しては &lt;code&gt;new&lt;/code&gt; として扱っています。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L2526-L2527"&gt;ExoPlayerImplInternal.java#L2526-L2527&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;次の &lt;code&gt;Timeline.Period&lt;/code&gt; がプレースホルダーである場合についての言及です。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L2528"&gt;ExoPlayerImplInternal.java#L2528&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;isUsingPlaceholderPeriod()&lt;/code&gt; は &lt;code&gt;Timeline.Period.isPlaceholder&lt;/code&gt; を使って確認します（この時 Timeline.isEmptyに関する検査はアーリーリターンをしているため不要です）。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L2682-L2687"&gt;ExoPlayerImplInternal.java#L2682-L2687&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;そして、 &lt;code&gt;oldContentPosition&lt;/code&gt; を ad かどうかとプレースホルダーかどうかに留意しながら決定します。 &lt;code&gt;newContentPosition&lt;/code&gt; は一時的に &lt;code&gt;oldContentPosition&lt;/code&gt; と一致させます（のちに変更するわけです）。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L2529-L2533"&gt;ExoPlayerImplInternal.java#L2529-L2533&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;その後に、シークを考慮しながら以下の値を決定していきます。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;int startAtDefaultPositionWindowIndex = C.INDEX_UNSET;
boolean forceBufferingState = false;
boolean endPlayback = false;
boolean setTargetLiveOffset = false;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/029a2b27cbdc27cf9d51d4a73ebeb503968849f6/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L2534-L2537"&gt;ExoPlayerImplInternal.java#L2534-L2537&lt;/a&gt;&lt;/p&gt;
&lt;h5&gt;一度目のペンディングされたシークかどうか&lt;/h5&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/029a2b27cbdc27cf9d51d4a73ebeb503968849f6/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L2538"&gt;ExoPlayerImplInternal.java#L2538&lt;/a&gt;&lt;/p&gt;
&lt;h6&gt;resolveSeekPosition&lt;/h6&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/029a2b27cbdc27cf9d51d4a73ebeb503968849f6/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L2796"&gt;ExoPlayerImplInternal.java#L2796&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;引数として、位置の特定に必要な &lt;code&gt;Timeline&lt;/code&gt;・&lt;code&gt;Timeline.Window&lt;/code&gt;・&lt;code&gt;Timeline.Period&lt;/code&gt;と &lt;code&gt;SeekPosition&lt;/code&gt;、後はパラメータ類です。（&lt;code&gt;boolean trySubsequentPeriods, @RepeatMode int repeatMode, boolean shuffleModeEnabled&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;中身は複雑なので深く触れませんが、 &lt;code&gt;Timeline.getPeriodPosition(window, period, seekPosition.windowIndex, seekPosition.windowPositionUs);&lt;/code&gt; を読んでその値を返します。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;resolveSeekPosition()&lt;/code&gt;が呼ばれ、結果がnullなら &lt;code&gt;endPlayback = true, startAtDefaultPositionWindowIndex = timeline.getFirstWindowIndex(shuffleModeEnabled);&lt;/code&gt; となります。これはどうやらinitial seekに失敗した場合のようです。  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;かなり曖昧なので、明日も続きを書いていきます。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;PositionUpdateForPlaylistChange&lt;/h3&gt;
&lt;p&gt;名前の通りのデータクラスです。&lt;br&gt;
&lt;code&gt;private final static class&lt;/code&gt; なので、完全に &lt;code&gt;ExoPlayerImplInternal&lt;/code&gt; のみで利用されます （ExoPlayerImplInternalの1つの特徴でこのクラスより下の階層のクラスがないためだと考えます）。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L2935"&gt;ExoPlayerImplInternal.java#L2935&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;やはりExoPlayerImplInternalのあるメソッドまで落ちてくる。 &lt;code&gt;resolveSeekPosition()&lt;/code&gt; の続きからは https://github.com/dev-platong/dev-platong.github.io/issues/19。&lt;/p&gt;</content><category term="ExoPlayer"></category></entry><entry><title>SimpleExoPlayerの生成時</title><link href="/simpleexoplayernosheng-cheng-shi.html" rel="alternate"></link><published>2023-02-27T00:00:00+09:00</published><updated>2023-02-27T00:00:00+09:00</updated><author><name>dev-platong</name></author><id>tag:None,2023-02-27:/simpleexoplayernosheng-cheng-shi.html</id><summary type="html">&lt;h2&gt;Constructing時に関連するクラス・プロパティ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;PriorityTaskManager： その名の通り優先的にタスクを実行するクラス&lt;/li&gt;
&lt;li&gt;AudioAttributes： 全てのAPIでサポートでき …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;h2&gt;Constructing時に関連するクラス・プロパティ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;PriorityTaskManager： その名の通り優先的にタスクを実行するクラス&lt;/li&gt;
&lt;li&gt;AudioAttributes： 全てのAPIでサポートできる android.media.AudioAttributes の強化版&lt;/li&gt;
&lt;li&gt;VideoScalingMode： クロップかfitするためのスケールしかない。デフォルトはfit。MediaCodecベースの Renderer が利用可能で、SurfaceViewが出力に指定されている時に利用できる。&lt;/li&gt;
&lt;li&gt;VideoChangeFrameRateStrategy：後述&lt;/li&gt;
&lt;li&gt;skipSilenceEnabled：無音の音声ストリームをスキップするか、デフォルトはfalse&lt;/li&gt;
&lt;li&gt;detachSurfaceTimeoutMs： プレイヤーからSurfaceがデタッチされるタイムアウト秒数（ms）。&lt;/li&gt;
&lt;li&gt;ComponentListener： 一般的な説明は後述。SimpleExoPlayerは、AnalyticsCollectorと、個別に登録したlisntersに処理を委譲するだけだが、例外もいくつかあるため都度覗くこと。&lt;/li&gt;
&lt;li&gt;FrameMetadataListener：ビデオフレームに紐付くメタデータのリッスンと、カメラモーションのリッスン。&lt;/li&gt;
&lt;li&gt;renderes：RendererFactoryから生成します。&lt;/li&gt;
&lt;li&gt;volume：デフォルトで1です。&lt;/li&gt;
&lt;li&gt;currentCues：空のリスト&lt;/li&gt;
&lt;li&gt;throwsWhenUsingWrongThread：デフォルトでtrueです。再生スレッド以外からプレイヤーが触れられた時に例外をスローします。&lt;/li&gt;
&lt;li&gt;AudioBecomingNoisyManager：後述&lt;/li&gt;
&lt;li&gt;AudioFocusManager：　Audio Focusが何のことか分からないので&lt;a href="https://github.com/dev-platong/dev-platong.github.io/issues/12"&gt;いずれ調べます。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;StreamVolumeManager： android.media.AudioManagerのラップクラスです。音声ストリームのボリュームを扱います。&lt;/li&gt;
&lt;li&gt;WakeLockManager：&lt;a href="https://developer.android.com/training/scheduling/wakelock?hl=ja"&gt;androidのWakeLock&lt;/a&gt;を扱います。&lt;/li&gt;
&lt;li&gt;WifiLockManager：&lt;a href="https://developer.android.com/reference/android/net/wifi/WifiManager.WifiLock"&gt;androidのWifiLock&lt;/a&gt;を扱います。&lt;/li&gt;
&lt;li&gt;DeviceInfo：再生しているデバイスの情報を持ちます。といってもローカルかリモートか（キャスト）とminVolumeとmaxVolumeくらいです。（命名変更が求められるところ）&lt;/li&gt;
&lt;li&gt;videoSize：VideoSize.UNKNOWNで生成されます。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;その後は、rendererにメッセージをセットして終わりです。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java#L430"&gt;SimpleExoPlayer.java#L430&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;VideoChangeFrameRateStrategy&lt;/h3&gt;
&lt;p&gt;MediaCodecベースのRendererが利用可能な場合に利用できる。&lt;br&gt;
アプリケーションは、 Surfaceの &lt;code&gt;CHANGE_FRAME_RATE_ALWAYS&lt;/code&gt; を &lt;code&gt;C#VIDEO_CHANGE_FRAME_RATE_STRATEGY_OFF&lt;/code&gt; にセットした上で、ExoPlayerが &lt;code&gt;Surface#setFrameRate&lt;/code&gt; を操作して実現する。&lt;/p&gt;
&lt;h3&gt;ComponentListener&lt;/h3&gt;
&lt;p&gt;ExoPlayerでは、各クラスでprivate finalで実装されているリスナーです。&lt;/p&gt;
&lt;h3&gt;AudioBecomingNoisyManager&lt;/h3&gt;
&lt;p&gt;デフォルトではBuilderの &lt;code&gt;handleAudioBecomingNoisy&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; のため、機能しません。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayer.java#L422"&gt;ExoPlayer.java#L422&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;この機能を &lt;code&gt;true&lt;/code&gt; にする場合には、&lt;code&gt;AUDIO_BECOMING_NOIDY&lt;/code&gt; の検出時に &lt;code&gt;playWhenReady&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; になります。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java#L2032-L2037"&gt;SimpleExoPlayer.java#L2032-L2037&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;ExoPlayerImplやExoPlayerImplInternalで具体的な処理を行うため、SimpleExoではより付加価値的なクラス生成を行なっている。&lt;br&gt;
明日は&lt;a href="/exoplayernosetmediaitemwodu-ndashi.html"&gt;ExoPlayer.setMediaItem()を追います。&lt;/a&gt;&lt;/p&gt;</content><category term="ExoPlayer"></category></entry><entry><title>ExoPlayerImplInternalの挙動を追う（生成まわり）</title><link href="/exoplayerimplinternalnoju-dong-wozhui-usheng-cheng-mawari.html" rel="alternate"></link><published>2023-02-24T00:00:00+09:00</published><updated>2023-02-24T00:00:00+09:00</updated><author><name>dev-platong</name></author><id>tag:None,2023-02-24:/exoplayerimplinternalnoju-dong-wozhui-usheng-cheng-mawari.html</id><summary type="html">&lt;h2&gt;ExoPlayerImplInternalの生成時&lt;/h2&gt;
&lt;h3&gt;LoadControl関連&lt;/h3&gt;
&lt;p&gt;LoadControl から 巻き戻し関連の値を取得する。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L248-L249"&gt;ExoPlayerImplInternal.java#L248-L249&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;PlaybackInfo関連&lt;/h3&gt;
&lt;p&gt;ダミーのPlaybackInfoインスタンスと、それに基づく PlaybackInfoUpdateク …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;ExoPlayerImplInternalの生成時&lt;/h2&gt;
&lt;h3&gt;LoadControl関連&lt;/h3&gt;
&lt;p&gt;LoadControl から 巻き戻し関連の値を取得する。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L248-L249"&gt;ExoPlayerImplInternal.java#L248-L249&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;PlaybackInfo関連&lt;/h3&gt;
&lt;p&gt;ダミーのPlaybackInfoインスタンスと、それに基づく PlaybackInfoUpdateクラスを作る。&lt;/p&gt;
&lt;p&gt;PlaybackInfoUpdateクラスは ExoPlayerImplInternal で定義されるクラス。&lt;br&gt;
保持されている PlaybackInfo の情報が外部に伝わっているとは限らない（pengingされている）。&lt;br&gt;
&lt;code&gt;void incrementPendingOperationAcks(int operationAcks)&lt;/code&gt; が呼び出されるタイミングで pending が解除される。&lt;br&gt;
&lt;code&gt;incrementPendingOperationAcks&lt;/code&gt; は ExoPlayerImpl と ExoPlayerImplInternal だけで使用される。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L251-L252"&gt;ExoPlayerImplInternal.java#L251-L252&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Renderer関連&lt;/h3&gt;
&lt;p&gt;Rendererの再生特性（DRMをサポートするか・トンネルモードをサポートするかなど）を配列で保持する。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L253-L257"&gt;ExoPlayerImplInternal.java#L253-L257&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;PlayerMessage関連&lt;/h3&gt;
&lt;h4&gt;PlayerMessageクラス&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;package com.google.android.exoplayer2&lt;/code&gt; にある、Playerに何か挙動を引き起こすためメッセージ。スレッドが死んでいる場合に実行を中止したり、pendingしたりできる点でCommandパターンに近い。&lt;/p&gt;
&lt;p&gt;Senderインターフェースを実装するものから送出され、Targetインターフェースを持つものが受け取る。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/PlayerMessage.java"&gt;PlayerMessage.java&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;PendingMessageInfo&lt;/h4&gt;
&lt;p&gt;ExoPlayerImplInternal特有のクラス。PlayerMessageがどの位置で解決されたかを、&lt;code&gt;periodIndex&lt;/code&gt;, &lt;code&gt;periodTimeUs&lt;/code&gt;, &lt;code&gt;periodUid&lt;/code&gt; で保持する。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L259"&gt;ExoPlayerImplInternal.java#L259&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Timeline関連&lt;/h3&gt;
&lt;p&gt;Timeline.WindowとTimeline.Periodをそれぞれフィールドに保持する。&lt;/p&gt;
&lt;p&gt;もしTimelineに詳しくない場合はわかりやすい&lt;a href="https://exoplayer.dev/doc/reference/com/google/android/exoplayer2/Timeline.html"&gt;com/google/android/exoplayer2/Timeline.html&lt;/a&gt;を参照のこと。&lt;/p&gt;
&lt;p&gt;この時、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Windowは 単一のwindow uidと空のmediaItem&lt;/li&gt;
&lt;li&gt;Periodは 広告再生ステートではない状態&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;で生成される。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L261-L262"&gt;ExoPlayerImplInternal.java#L261-L262&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;TrackSelector関連&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;init(InvalidationListener listener, BandwidthMeter bandwidthMeter)&lt;/code&gt; が呼ばれるが、引数をフィールドに保持するだけのため、一般的なソフトウェアにおいてはコンストラクタのような内容である。しかしExoPlayerはサブコンポーネントの振る舞いをDIよって変更できる設計であるため、コンストラクタがその旨で利用される。そのためこちらは&lt;code&gt;init&lt;/code&gt;となっているのではないかと推察できる。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;InvalidationListener&lt;/code&gt; は、以前のトラック選択で選択され利用中の &lt;code&gt;Track&lt;/code&gt; を失効させるための処理を担うハンドラのリスナー。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L263"&gt;ExoPlayerImplInternal.java#L263&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;MediaPeriodQueueクラス&lt;/h3&gt;
&lt;p&gt;MediaPeriodを保持し、先頭のメディアが読まれるキュー。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/029a2b27cbdc27cf9d51d4a73ebeb503968849f6/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodQueue.java#L33-L37"&gt;MediaPeriodQueue.java#L33-L37&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ExoPlayerImplInternalのコンストラクタで生成される。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L268"&gt;ExoPlayerImplInternal.java#L268&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;MediaPeriodQueueクラスのコンストラクタでPeriodとWindowを生成するが、これは ExoPlayerImplInternalのPeriod・Windowインスタンスとは別物であることに注意。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/029a2b27cbdc27cf9d51d4a73ebeb503968849f6/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodQueue.java#L90"&gt;MediaPeriodQueue.java#L90&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;スレッド関連&lt;/h3&gt;
&lt;p&gt;新しい Thread, Looper, Handler が生成され保持される。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L271-L276"&gt;ExoPlayerImplInternal.java#L271-L276&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;一旦ここまでで ExoPlayerが生成された時の関連クラスは把握できた。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保持を目的とするPlaybackInfoUpdate・PlayerMessageInfo・MediaPeriodQueueの初期化を行う。&lt;/li&gt;
&lt;li&gt;Window/Periodを生成する。&lt;/li&gt;
&lt;li&gt;TrackSelectorを初期化する。&lt;/li&gt;
&lt;li&gt;RendererCapabilitiesの取得を行う。&lt;/li&gt;
&lt;li&gt;スレッドを生成する。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;明日は低遅延周りを理解したいため、 &lt;a href="{filename}./exoplayer_live_playback_speed_control.md"&gt;&lt;code&gt;LivePlaybackSpeedControl&lt;/code&gt; を深追いする。&lt;/a&gt;&lt;/p&gt;</content><category term="ExoPlayer"></category></entry><entry><title>ExoPlayerが生成される時、具体的にはどんなクラスが生成されるのか</title><link href="/exoplayergasheng-cheng-sarerushi-ju-ti-de-nihadonnakurasugasheng-cheng-sarerunoka.html" rel="alternate"></link><published>2023-02-23T00:00:00+09:00</published><updated>2023-02-23T00:00:00+09:00</updated><author><name>dev-platong</name></author><id>tag:None,2023-02-23:/exoplayergasheng-cheng-sarerushi-ju-ti-de-nihadonnakurasugasheng-cheng-sarerunoka.html</id><summary type="html">&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;ExoPlayerでの再生問題におけるトラブルシューティング迅速化のため、再生に関わるクラスを把握する。&lt;br&gt;
今回はDefault実装 …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;ExoPlayerでの再生問題におけるトラブルシューティング迅速化のため、再生に関わるクラスを把握する。&lt;br&gt;
今回はDefault実装での ExoPlayer の生成時にどのようなクラスがインスタンス化され、それ以降に処理を委譲するために保持されているのか調査する。&lt;/p&gt;
&lt;h2&gt;環境&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ソフトウェア&lt;/th&gt;
&lt;th&gt;バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ExoPlayer&lt;/td&gt;
&lt;td&gt;&lt;a href="https://github.com/google/ExoPlayer/releases/tag/r2.16.1"&gt;r2.16.1&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;検証には &lt;code&gt;ExoPlayer.demo&lt;/code&gt; モジュールを利用する。&lt;/p&gt;
&lt;h2&gt;基礎知識&lt;/h2&gt;
&lt;p&gt;ExoPlayerではコンポーネントと呼ばれる一定の責務を持った塊がinterfaceとして存在し、各コンポーネントがDefault実装を持っているという構成を持っている。&lt;br&gt;
コンポーネントはインジェクトをサポートするので、サブコンポーネントにおける振る舞いをコンストラクタ経由でカスタムクラスを注入することで変更することができる。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayer.java#L102-L112"&gt;ExoPlayer.java#L102-L112&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;基本的にはよほど要件が複雑でない限りは、ライブラリが提供するDefault実装を使うことになるので、今回もDefault実装を使っていく。&lt;/p&gt;
&lt;h2&gt;ExoPlayerの生成&lt;/h2&gt;
&lt;p&gt;ExoPlayerインターフェース の実装である、 SimpleExoPlayerクラス が ExoPlayerインターフェースのbuilder から生成される。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayer.java#L967"&gt;ExoPlayer.java#L967&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;この時、 SimpleExoPlayerクラス では ExoPlayerImplクラスを生成し、playerフィールドに保持する。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java#L479"&gt;SimpleExoPlayer.java#L479&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;ExoPlayerImplインスタンスの生成時&lt;/h3&gt;
&lt;p&gt;Renderer・TrackSelector・MediaSourceFactory・LoadControl・BandwidthMeter・AnalyticsCollector・LivePlaybackSpeedControl・Clock・Playerなどが与えられる。&lt;br&gt;
各クラスの概要は以下にまとめるが、それぞれの詳細は追って記事にしていく。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java#L154"&gt;ExoPlayerImpl.java#L154&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;クラス名&lt;/th&gt;
&lt;th&gt;役割の概略&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Renderer&lt;/td&gt;
&lt;td&gt;SampleStreamコンポーネントからメディアを読み込む&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TrackSelector&lt;/td&gt;
&lt;td&gt;Rendererコンポーネントによって消費されるトラックを選択する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MediaSourceFactory&lt;/td&gt;
&lt;td&gt;MediaItemクラスからMediaSourceを生成する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LoadControl&lt;/td&gt;
&lt;td&gt;バッファリングをコントロールする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BandwidthMeter&lt;/td&gt;
&lt;td&gt;現在利用可能な帯域幅を推測する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AnalyticsCollector&lt;/td&gt;
&lt;td&gt;AnalyticsListenerコンポーネントにイベントを収集し送る&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LivePlaybackSpeedControl&lt;/td&gt;
&lt;td&gt;着実にターゲットライブオフセットを維持するために速度をコントロールする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Clock&lt;/td&gt;
&lt;td&gt;System Clockの抽象化と、HandlerWrapperコンポーネントの生成&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Player&lt;/td&gt;
&lt;td&gt;あるならばラップして使うためのPlayer&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;コンストラクタではdummyとなる値を生成し、最後に ExoPlayerInternalインスタンスを生成する。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.16.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java#L250"&gt;ExoPlayerImpl.java#L250&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ExoPlayerImplからExoPlayerImplInternalに渡される引数は、SimpleExoPlayerからExoPlayerImplに渡されるものとほとんど変わらない。&lt;br&gt;
このことからExoPlayerImplInternalは、ExoPlayerImplが内部的に保持するインスタンスの操作を担っていそうだということが推測できる。&lt;/p&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ExoPlayer.Builder -&amp;gt; SimpleExoPlayer -&amp;gt; ExoPlayerImpl -&amp;gt; ExoPlayerInternal と生成される。&lt;/li&gt;
&lt;li&gt;SimpleExoPlayerのコンストラクタの時点で生成し、引数としてコンストラクタに渡されたクラスの実際の操作をExoPlayerImplInternalが責務として持つ。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;明日は&lt;a href="/exoplayerimplinternalnoju-dong-wozhui-usheng-cheng-mawari.html"&gt;ExoPlayerImplInternalの生成時の振る舞いを掘り下げていく。&lt;/a&gt;&lt;/p&gt;</content><category term="ExoPlayer"></category></entry><entry><title>BehindLiveWindowExceptionの意味と対策</title><link href="/behindlivewindowexceptionnoyi-wei-todui-ce.html" rel="alternate"></link><published>2022-05-17T00:00:00+09:00</published><updated>2022-05-17T00:00:00+09:00</updated><author><name>dev-platong</name></author><id>tag:None,2022-05-17:/behindlivewindowexceptionnoyi-wei-todui-ce.html</id><content type="html">&lt;h1&gt;Overview&lt;/h1&gt;
&lt;h1&gt;前提&lt;/h1&gt;
&lt;p&gt;ExoPlayer version r2.17.1&lt;/p&gt;</content><category term="ExoPlayer"></category></entry><entry><title>ExoPlayerにおける低遅延再生の再生位置調整</title><link href="/exoplayerniokerudi-chi-yan-zai-sheng-nozai-sheng-wei-zhi-diao-zheng.html" rel="alternate"></link><published>2022-05-15T00:00:00+09:00</published><updated>2022-05-15T00:00:00+09:00</updated><author><name>dev-platong</name></author><id>tag:None,2022-05-15:/exoplayerniokerudi-chi-yan-zai-sheng-nozai-sheng-wei-zhi-diao-zheng.html</id><summary type="html">&lt;h1&gt;Overview&lt;/h1&gt;
&lt;p&gt;ExoPlayerにおける低遅延サポートについて、再生位置調整機能だけが低遅延に特有であると仮定してその詳細をまとめ …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Overview&lt;/h1&gt;
&lt;p&gt;ExoPlayerにおける低遅延サポートについて、再生位置調整機能だけが低遅延に特有であると仮定してその詳細をまとめます。
&lt;code&gt;DefaultLivePlaybackSpeedControl&lt;/code&gt; が最も関係する実クラスで、バッファの状態を考慮し、過去の計算結果を考慮する緩やかな変化を再生速度とライブオフセットに加える設計になっています。&lt;/p&gt;
&lt;h1&gt;前提&lt;/h1&gt;
&lt;h2&gt;使用バージョン&lt;/h2&gt;
&lt;p&gt;r2.17.1&lt;/p&gt;
&lt;h2&gt;前提知識&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://exoplayer.dev/doc/reference/com/google/android/exoplayer2/MediaItem.LiveConfiguration.html"&gt;MediaItem.LiveConfiguration&lt;/a&gt;に設定できるパラメータ&lt;/p&gt;
&lt;p&gt;オフセットと再生速度でMin/Maxを設定できます。オフセットのみターゲットオフセットも設定します。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.17.1/docs/live-streaming.md"&gt;exoplayer.devのLiveStreamingのdocs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Playerを構成する際にビルダーに共通のライブ再生に関する位置調整のパラメータを設定するか、MediaItem毎に設定するかという2つの手段があります。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="/exoplayerniokeruliveoffset.html"&gt;LiveOffsetとは何か&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;再生位置調整機能&lt;/h1&gt;
&lt;p&gt;ExoPlayerではインターフェースがまず提供されていて、そのデフォルト実装があるというコードベース全体の慣習があります。&lt;/p&gt;
&lt;p&gt;再生位置調整機能に該当するのは、 &lt;code&gt;LivePlaybackSpeedControl&lt;/code&gt; インターフェースと &lt;code&gt;DefaultLivePlaybackSpeedControl&lt;/code&gt; クラスになります。&lt;/p&gt;
&lt;p&gt;再生位置調整機能は、低遅延ストリームで通常で有効です。低遅延ではないライブストリームでは明治的に再生速度のMAX/MINを指定することで有効になります。 SEE: &lt;a href="https://github.com/google/ExoPlayer/releases/tag/r2.17.0#:~:text=Disable%20automatic%20speed%20adjustment%20for%20live%20streams%20that%20neither%20have%20low%2Dlatency%20features%20nor%20a%20user%20request%20setting%20the%20speed"&gt;r2.17.0 release note&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注意： r2.13.0~2.16.1 では低遅延ではないライブストリームでも再生位置調整機能がデフォルトで有効でした。 SEE：https://github.com/google/ExoPlayer/issues/9329&lt;/p&gt;
&lt;h2&gt;LivePlaybackSpeedControl インターフェース&lt;/h2&gt;
&lt;p&gt;5つのメソッドがあります。&lt;/p&gt;
&lt;h3&gt;void setLiveConfiguration(LiveConfiguration liveConfiguration)&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;MediaItem&lt;/code&gt; から渡ってくる &lt;code&gt;LiveConfiguration&lt;/code&gt; のセッター。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;   * Sets the live configuration defined by the media.&lt;/span&gt;
&lt;span class="cm"&gt;   *&lt;/span&gt;
&lt;span class="cm"&gt;   * @param liveConfiguration The {@link LiveConfiguration} as defined by the media.&lt;/span&gt;
&lt;span class="cm"&gt;   */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;setLiveConfiguration&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LiveConfiguration&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;liveConfiguration&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.17.1/library/core/src/main/java/com/google/android/exoplayer2/LivePlaybackSpeedControl.java#L26-L31"&gt;LivePlaybackSpeedControl.java#L26-L31&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;void setTargetLiveOffsetOverrideUs(long liveOffsetUs)&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;LiveConfiguration&lt;/code&gt; 経由で targetLiveOffset が設定されている場合に targetLiveOffsetをオーバーライドするメソッドです。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;   * Sets the target live offset in microseconds that overrides the live offset {@link&lt;/span&gt;
&lt;span class="cm"&gt;   * #setLiveConfiguration configured} by the media. Passing {@code C.TIME_UNSET} deletes a previous&lt;/span&gt;
&lt;span class="cm"&gt;   * override.&lt;/span&gt;
&lt;span class="cm"&gt;   *&lt;/span&gt;
&lt;span class="cm"&gt;   * &amp;lt;p&amp;gt;If no target live offset is configured by {@link #setLiveConfiguration}, this override has&lt;/span&gt;
&lt;span class="cm"&gt;   * no effect.&lt;/span&gt;
&lt;span class="cm"&gt;   */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;setTargetLiveOffsetOverrideUs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;long&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;liveOffsetUs&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.17.1/library/core/src/main/java/com/google/android/exoplayer2/LivePlaybackSpeedControl.java#L33-L41"&gt;LivePlaybackSpeedControl.java#L33-L41&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;void notifyRebuffer()&lt;/h3&gt;
&lt;p&gt;ユーザーインタラクションではなくバッファの不足によるリバッファリングを通知します。ただし、最初のバッファリングとシークによるバッファリング時にはこのメソッドは呼び出されません。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;  /**
   * Notifies the live playback speed control that a rebuffer occurred.
   *
   * &amp;lt;p&amp;gt;A rebuffer is defined to be caused by buffer depletion rather than a user action. Hence this
   * method is not called during initial buffering or when buffering as a result of a seek
   * operation.
   */
  void notifyRebuffer();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.17.1/library/core/src/main/java/com/google/android/exoplayer2/LivePlaybackSpeedControl.java#L43-L50"&gt;LivePlaybackSpeedControl.java#L43-L50&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;float getAdjustedPlaybackSpeed(long liveOffsetUs, long bufferedDurationUs)&lt;/h3&gt;
&lt;p&gt;現在のオフセット位置とバッファ位置を渡すことで、調整済み速度を返します。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;   * Returns the adjusted playback speed in order get closer towards the {@link&lt;/span&gt;
&lt;span class="cm"&gt;   * #getTargetLiveOffsetUs() target live offset}.&lt;/span&gt;
&lt;span class="cm"&gt;   *&lt;/span&gt;
&lt;span class="cm"&gt;   * @param liveOffsetUs The current live offset, in microseconds.&lt;/span&gt;
&lt;span class="cm"&gt;   * @param bufferedDurationUs The duration of media that&amp;#39;s currently buffered, in microseconds.&lt;/span&gt;
&lt;span class="cm"&gt;   * @return The adjusted factor by which playback should be sped up.&lt;/span&gt;
&lt;span class="cm"&gt;   */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nc"&gt;float&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;getAdjustedPlaybackSpeed&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;long&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;liveOffsetUs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;long&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bufferedDurationUs&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.17.1/library/core/src/main/java/com/google/android/exoplayer2/LivePlaybackSpeedControl.java#L52-L60"&gt;LivePlaybackSpeedControl.java#L52-L60&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;long getTargetLiveOffsetUs()&lt;/h3&gt;
&lt;p&gt;現在のターゲットオフセットを返します。この値は初めにMediaItemから渡された値ではなく、調整を続けて変動した値になります。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;   * Returns the current target live offset, in microseconds, or {@link C#TIME_UNSET} if no target&lt;/span&gt;
&lt;span class="cm"&gt;   * live offset is defined for the current media.&lt;/span&gt;
&lt;span class="cm"&gt;   */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;long&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;getTargetLiveOffsetUs&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.17.1/library/core/src/main/java/com/google/android/exoplayer2/LivePlaybackSpeedControl.java#L62-L66"&gt;LivePlaybackSpeedControl.java#L62-L66&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;DefaultLivePlaybackSpeedControl クラス&lt;/h2&gt;
&lt;p&gt;以下の解説は全てデフォルト値を使用する場合です。
先にprivateメソッドを解説し、それを利用する &lt;code&gt;LivePlaybackSpeedControl&lt;/code&gt; インターフェースの振る舞いを追います。&lt;/p&gt;
&lt;h3&gt;初期値&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;fallbackMinPlaybackSpeed：0.97&lt;/li&gt;
&lt;li&gt;fallbackMaxPlaybackSpeed: 1.03&lt;/li&gt;
&lt;li&gt;minUpdateIntervalMs：1_000&lt;/li&gt;
&lt;li&gt;smoothedMinPossibleLiveOffsetUs：&lt;code&gt;C.TIME_UNSET&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;smoothedMinPossibleLiveOffsetDeviationUs：&lt;code&gt;C.TIME_UNSET&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;targetLiveOffsetを必要ならばリセットする&lt;/h3&gt;
&lt;p&gt;内部の振る舞いです（privateメソッド）。&lt;/p&gt;
&lt;p&gt;idealTargetOffsetの値を更新します。&lt;br&gt;
優先順位は、&lt;code&gt;mediaConfigurationTargetLiveOffsetUs &amp;lt; targetLiveOffsetOverrideUs&lt;/code&gt; となります。&lt;/p&gt;
&lt;p&gt;以前と同じ &lt;code&gt;idealTargetOffset&lt;/code&gt; の値で上書きはせず、アーリーリターンします。&lt;/p&gt;
&lt;p&gt;このことから、 MediaItem経由のLiveConfigurationのtargetOffsetではなく、&lt;code&gt;targetLiveOffsetOverrideUs&lt;/code&gt;が途中で設定された場合などに実際の更新処理が実行されることが推測できます。&lt;/p&gt;
&lt;p&gt;更新処理は以下の通りです。以前の値を考慮する計算になっているため、targetLiveOffsetの計算に利用される「以前のデータ」をクリアし、内部の状態を1度目の計算に適する形に戻します。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;idealTargetLiveOffsetUs = idealOffsetUs;
currentTargetLiveOffsetUs = idealOffsetUs;
smoothedMinPossibleLiveOffsetUs = C.TIME_UNSET;
smoothedMinPossibleLiveOffsetDeviationUs = C.TIME_UNSET;
lastPlaybackSpeedUpdateMs = C.TIME_UNSET;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.17.1/library/core/src/main/java/com/google/android/exoplayer2/DefaultLivePlaybackSpeedControl.java#L385-L389"&gt;DefaultLivePlaybackSpeedControl.java#L385-L389&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;LivePlaybackSpeedControl&lt;/code&gt; インターフェースで定義される &lt;code&gt;setLiveConfiguration&lt;/code&gt; か &lt;code&gt;setTargetLiveOffsetOverrideUs&lt;/code&gt; で使用されます。&lt;/p&gt;
&lt;h3&gt;線形平滑化（smooth)&lt;/h3&gt;
&lt;p&gt;値を急激ではなく滑らかに変更するための著名なアルゴリズムです。変化前の値と変化後の値を割合で足し合わせます（金魚の水槽の水を全ては変えず半分だけ変えるみたいなことです）。&lt;/p&gt;
&lt;p&gt;この時の足し合わせる割合は &lt;code&gt;smoothingFactor&lt;/code&gt; です。本クラスでは、LiveOffsetを最小にする場合、つまり最も攻めたLiveOffsetを計算する場合に利用され、デフォルト値は &lt;code&gt;0.999f&lt;/code&gt; です。SEE: &lt;a href="https://github.com/google/ExoPlayer/blob/r2.17.1/library/core/src/main/java/com/google/android/exoplayer2/DefaultLivePlaybackSpeedControl.java#L80-L84"&gt;DefaultLivePlaybackSpeedControl.java#L80-L84&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;このため、&lt;code&gt;変化後の値:前&lt;/code&gt; を &lt;code&gt;1:999&lt;/code&gt; の割合で足し合わせます。ほとんど変化しないということです。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nv"&gt;private&lt;/span&gt; &lt;span class="nv"&gt;static&lt;/span&gt; &lt;span class="nv"&gt;long&lt;/span&gt; &lt;span class="nv"&gt;smooth&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;long&lt;/span&gt; &lt;span class="nv"&gt;smoothedValue&lt;/span&gt;, &lt;span class="nv"&gt;long&lt;/span&gt; &lt;span class="nv"&gt;newValue&lt;/span&gt;, &lt;span class="nv"&gt;float&lt;/span&gt; &lt;span class="nv"&gt;smoothingFactor&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt; {
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;long&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt; &lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;smoothingFactor&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nv"&gt;smoothedValue&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="nv"&gt;f&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;smoothingFactor&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nv"&gt;newValue&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;&lt;span class="c1"&gt;;&lt;/span&gt;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.17.1/library/core/src/main/java/com/google/android/exoplayer2/DefaultLivePlaybackSpeedControl.java#L447-L449"&gt;DefaultLivePlaybackSpeedControl.java#L447-L449&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;smoothedMinPossibleLiveOffsetUs （以前の値を考慮した最も攻めたLiveOffset） の更新&lt;/h3&gt;
&lt;p&gt;前提：&lt;code&gt;smoothedMinPossibleLiveOffsetUs&lt;/code&gt;の初期値は &lt;code&gt;C.TIME_UNSET&lt;/code&gt; です。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;バッファを使い切る最も攻めた &lt;code&gt;minPossibleLiveOffsetUs&lt;/code&gt; を計算します。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;long minPossibleLiveOffsetUs = liveOffsetUs - bufferedDurationUs;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;1回目の計算であれば &lt;code&gt;minPossibleLiveOffsetUs&lt;/code&gt; を採用してアーリーリターンします。&lt;/p&gt;
&lt;p&gt;この時、&lt;code&gt;smoothedMinPossibleLiveOffsetDeviationUs&lt;/code&gt; は 0に設定します。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;if (smoothedMinPossibleLiveOffsetUs == C.TIME_UNSET) {
  smoothedMinPossibleLiveOffsetUs = minPossibleLiveOffsetUs;
  smoothedMinPossibleLiveOffsetDeviationUs = 0;
} else {&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;N回目（N&amp;gt;=2）以降の計算の場合、N-1回目に計算した &lt;code&gt;smoothedMinPossibleLiveOffsetUs&lt;/code&gt; と &lt;code&gt;minPossibleLiveOffsetUs&lt;/code&gt; を用いて平滑化を行います。その値と &lt;code&gt;minPossibleLiveOffsetUs&lt;/code&gt; のうち安全のためにより長いLiveOffsetを &lt;code&gt;smoothedMinPossibleLiveOffsetUs&lt;/code&gt; とします。&lt;/p&gt;
&lt;p&gt;この時、&lt;code&gt;smoothedMinPossibleLiveOffsetUs&lt;/code&gt;は1秒以上前の計算結果である一方で、&lt;code&gt;minPossibleLiveOffsetUs&lt;/code&gt; はバッファを考慮した今回の値であることに注意してください。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;// Use the maximum here to ensure we keep track of the upper bound of what is safely possible,
  // not the average.
  smoothedMinPossibleLiveOffsetUs =
      max(
          minPossibleLiveOffsetUs,
          smooth(
              smoothedMinPossibleLiveOffsetUs,
              minPossibleLiveOffsetUs,
              minPossibleLiveOffsetSmoothingFactor));&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;smoothedMinPossibleLiveOffsetDeviationUs&lt;/code&gt; を計算します。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;long minPossibleLiveOffsetDeviationUs =
      abs(minPossibleLiveOffsetUs - smoothedMinPossibleLiveOffsetUs);
  smoothedMinPossibleLiveOffsetDeviationUs =
      smooth(
          smoothedMinPossibleLiveOffsetDeviationUs,
          minPossibleLiveOffsetDeviationUs,
          minPossibleLiveOffsetSmoothingFactor);&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.17.1/library/core/src/main/java/com/google/android/exoplayer2/DefaultLivePlaybackSpeedControl.java#L392-L415"&gt;DefaultLivePlaybackSpeedControl.java#L392-L415&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;targetLiveOffsetの調整&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安全そうなsafeOffsetを計算します。&lt;/p&gt;
&lt;p&gt;推測：前回とのliveOffsetの変化差分が3倍以上になるケースはほとんどないということを意味しているのだと思います。このケースに対応できないのは、3GネットワークからWi-fiに接続先が切り替わり、ネットワークの速度が劇的に改善する場合などです。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;// Stay in a safe distance (3 standard deviations = &amp;gt;99%) to the minimum possible live offset.
long safeOffsetUs =
    smoothedMinPossibleLiveOffsetUs + 3 * smoothedMinPossibleLiveOffsetDeviationUs;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;currentTargetOffsetがsafeOffsetより長いかを判断して処理を分岐させます。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;if (currentTargetLiveOffsetUs &amp;gt; safeOffsetUs) {&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（safeOffsetよりcurrentTargetLiveOffsetが大きい場合）度を超えて安全なのでcurrentTargetLifeOffsetを縮小します。&lt;/p&gt;
&lt;p&gt;maxDecrementUsの計算方法については、すみませんいまいちよくわかりません。&lt;/p&gt;
&lt;p&gt;おそらく、 &lt;code&gt;minUpdateIntervalUs&lt;/code&gt; を掛けているのは、値が大きくなると更新頻度が落ちるので、それを考慮して一回あたりの影響を上げるためだと思います。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;// There is room for decreasing the target offset towards the ideal or safe offset (whichever
  // is larger). We want to limit the decrease so that the playback speed delta we achieve is
  // the same as the maximum delta when slowing down towards the target.
  long minUpdateIntervalUs = Util.msToUs(minUpdateIntervalMs);
  long decrementToOffsetCurrentSpeedUs =
      (long) ((adjustedPlaybackSpeed - 1f) * minUpdateIntervalUs);
  long decrementToIncreaseSpeedUs = (long) ((maxPlaybackSpeed - 1f) * minUpdateIntervalUs);
  long maxDecrementUs = decrementToOffsetCurrentSpeedUs + decrementToIncreaseSpeedUs;
  currentTargetLiveOffsetUs =
      max(safeOffsetUs, idealTargetLiveOffsetUs, currentTargetLiveOffsetUs - maxDecrementUs);&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（safeOffsetよりcurrentTargetLiveOffsetが小さい場合）速度を落とした時に目指すべきtargetOffsetを計算します。&lt;/p&gt;
&lt;p&gt;考察：調整済み速度が1倍を下回る場合、目指すべきオフセットは &lt;code&gt;liveOffset&lt;/code&gt; （本メソッドの引数に渡されているOffset）です。 &lt;code&gt;proportionalControlFactor&lt;/code&gt; で割る理由は、速度変化が &lt;code&gt;proportionalControlFactor&lt;/code&gt; に影響を受けて現在の状況が減らされて反映されるため、それを元に戻すためだと推察されます。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;// We'd like to reach a stable condition where the current live offset stays just below the
  // safe offset. But don't increase the target offset to more than what would allow us to slow
  // down gradually from the current offset.
  long offsetWhenSlowingDownNowUs =
      liveOffsetUs - (long) (max(0f, adjustedPlaybackSpeed - 1f) / proportionalControlFactor);&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;currentTargetLiveOffset&lt;/code&gt; と &lt;code&gt;safeOffset&lt;/code&gt; の間に先ほど計算した &lt;code&gt;offsetWhenSlowingDownNowUs&lt;/code&gt; があるならばそれを採用します。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;currentTargetLiveOffsetUs =
      Util.constrainValue(offsetWhenSlowingDownNowUs, currentTargetLiveOffsetUs, safeOffsetUs);&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.17.1/library/core/src/main/java/com/google/android/exoplayer2/DefaultLivePlaybackSpeedControl.java#L417-L445"&gt;DefaultLivePlaybackSpeedControl.java#L417-L445&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;速度調整&lt;/h3&gt;
&lt;p&gt;liveOffsetとバッファの長さを渡す必要があります。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;MediaItem.LiveConfiguration&lt;/code&gt;に値が指定されていなければアーリーリターンします。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;if (mediaConfigurationTargetLiveOffsetUs == C.TIME_UNSET) {
  return 1f;
}&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最も攻めた平滑済みLiveOffsetを更新します。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;updateSmoothedMinPossibleLiveOffsetUs(liveOffsetUs, bufferedDurationUs);&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2回目の呼び出しで前回の更新から &lt;code&gt;minUpdateIntervalMs&lt;/code&gt; 以下の秒数しか経過していなければアーリーリターンします。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;if (lastPlaybackSpeedUpdateMs != C.TIME_UNSET
    &amp;amp;&amp;amp; SystemClock.elapsedRealtime() - lastPlaybackSpeedUpdateMs &amp;lt; minUpdateIntervalMs) {
  return adjustedPlaybackSpeed;
}&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;targetLiveOffsetを更新します。&lt;/p&gt;
&lt;p&gt;```
lastPlaybackSpeedUpdateMs = SystemClock.elapsedRealtime();&lt;/p&gt;
&lt;p&gt;adjustTargetLiveOffsetUs(liveOffsetUs);
```&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;オフセット誤差を取り、誤差に比例定数を掛けた値を1に足して、調整後の値とします。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;long liveOffsetErrorUs = liveOffsetUs - currentTargetLiveOffsetUs;
if (Math.abs(liveOffsetErrorUs) &amp;lt; maxLiveOffsetErrorUsForUnitSpeed) {
  adjustedPlaybackSpeed = 1f;
} else {
  float calculatedSpeed = 1f + proportionalControlFactor * liveOffsetErrorUs;
  adjustedPlaybackSpeed =
      Util.constrainValue(calculatedSpeed, minPlaybackSpeed, maxPlaybackSpeed);
}
return adjustedPlaybackSpeed;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.17.1/library/core/src/main/java/com/google/android/exoplayer2/DefaultLivePlaybackSpeedControl.java#L338-L361"&gt;DefaultLivePlaybackSpeedControl.java#L338-L361&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;notifyRebufferのコール時（ある条件のリバッファリングが起きた時）&lt;/h3&gt;
&lt;p&gt;currentTargetLiveOffsetが500ms増え、&lt;code&gt;lastPlaybackSpeedUpdateMs&lt;/code&gt; がアンセットされます。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nv"&gt;@Override&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;notifyRebuffer&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;currentTargetLiveOffsetUs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;TIME_UNSET&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;currentTargetLiveOffsetUs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;targetLiveOffsetRebufferDeltaUs&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;maxTargetLiveOffsetUs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;TIME_UNSET&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;currentTargetLiveOffsetUs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;maxTargetLiveOffsetUs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;currentTargetLiveOffsetUs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;maxTargetLiveOffsetUs&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;lastPlaybackSpeedUpdateMs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;TIME_UNSET&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.17.1/library/core/src/main/java/com/google/android/exoplayer2/DefaultLivePlaybackSpeedControl.java#L324-L335"&gt;DefaultLivePlaybackSpeedControl.java#L324-L335&lt;/a&gt;&lt;/p&gt;</content><category term="ExoPlayer"></category></entry><entry><title>ExoPlayerのRendererインターフェース</title><link href="/exoplayernorendererintahuesu.html" rel="alternate"></link><published>2022-03-09T00:00:00+09:00</published><updated>2022-03-09T00:00:00+09:00</updated><author><name>dev-platong</name></author><id>tag:None,2022-03-09:/exoplayernorendererintahuesu.html</id><summary type="html">&lt;h1&gt;Overview&lt;/h1&gt;
&lt;p&gt;満を辞してRendererを読みます。&lt;/p&gt;
&lt;h2&gt;責務&lt;/h2&gt;
&lt;p&gt;SampleStreamクラスからメディアをレンダリングします。&lt;br&gt;
内部的には ExoPlayer によってレンダラーの …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Overview&lt;/h1&gt;
&lt;p&gt;満を辞してRendererを読みます。&lt;/p&gt;
&lt;h2&gt;責務&lt;/h2&gt;
&lt;p&gt;SampleStreamクラスからメディアをレンダリングします。&lt;br&gt;
内部的には ExoPlayer によってレンダラーのライフサイクルは管理されます。&lt;br&gt;
レンダラーは可能なトラック変更と全ての再生状態のような様々なステートに移行します。&lt;/p&gt;
&lt;h2&gt;WakeUpLisener&lt;/h2&gt;
&lt;p&gt;いくつかのレンダラーは &lt;code&gt;render()&lt;/code&gt; メソッドが呼ばれるべき時を通知します。&lt;br&gt;
これはプレイヤーが次にウェイクアップするまでスリープすることを可能にします（タイトループの中で &lt;code&gt;render()&lt;/code&gt; メソッドを呼ぶ代わりです）。&lt;br&gt;
割り込みベースのスケジューリングの目的は、電力消費を抑えることにあります。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;void onSleep(long wakeupDeadlineMs)&lt;/li&gt;
&lt;li&gt;void onWakeup()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.17.0/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FRenderer.java#L59-L78"&gt;Renderer.java#L59-L78&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;MessageType&lt;/h2&gt;
&lt;p&gt;レンダラーに渡すことができるメッセージのタイプを示します。アプリケーション定義の値を &lt;code&gt;MSG_CUSTOM_BASE&lt;/code&gt; を使って持てることに注意。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;VIDEO_OUTPUT&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ExoPlayer.createMesssage()&lt;/code&gt; を通じてビデオレンダラに渡されるメッセージ。&lt;br&gt;
payloadはSurfaceであることが通常だが、いくつのビデオレンダラーは他の &lt;code&gt;VideoDecoderOutputBufferRenderer&lt;/code&gt; などにも出力できる。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;VOLUME&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ExoPlayer.createMesssage()&lt;/code&gt; を通じてオーディオレンダラに渡されるメッセージ。&lt;br&gt;
payloadは0~1のFloat。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AUDIO_ATTRIBUTES&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ExoPlayer.createMesssage()&lt;/code&gt; を通じてオーディオレンダラに渡されるメッセージ。  &lt;br&gt;
payloadはオーディオトラックに設定されることになる &lt;code&gt;AudioAttributes&lt;/code&gt; クラスのインスタンスであるべき。 何も設定されなければ、一般的なメディア再生に向いているデフォルトが使われる。&lt;br&gt;
再生中の設定がオーディオトラックを再生成することで短いオーディオギャップを生む可能性があります。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SCALING_MODE&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ExoPlayer.createMesssage()&lt;/code&gt; を通じてMediaCodecベースのビデオレンダラに渡されるメッセージ。payloadは &lt;code&gt;C.VideoScalingMode&lt;/code&gt; の1つである必要があります。&lt;br&gt;
Scalingモードは &lt;code&gt;android.view.SurfaceView&lt;/code&gt; によってターゲットレンダラーが所有されている時のみ利用可能です。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CHANGE_FRAME_RATE_STRATEGY&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ExoPlayer.createMesssage()&lt;/code&gt; を通じてビデオレンダラに渡されるメッセージ。&lt;br&gt;
payloadは&lt;code&gt;C.VideoChangeFrameRateStrategy&lt;/code&gt; の1つである必要があります。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AUX_EFFECT_INFO&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ExoPlayer.createMesssage()&lt;/code&gt; を通じてオーディオレンダラに渡されるメッセージ。  &lt;br&gt;
補助オーディオエフェクトを意味する &lt;code&gt;AuxEffectInfo&lt;/code&gt; がpayloadになるべきです。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;VIDEO_FRAME_METADATA_LISTEN&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ExoPlayer.createMesssage()&lt;/code&gt; を通じてビデオレンダラに渡されるメッセージ。&lt;br&gt;
&lt;code&gt;VideoFrameMetadataListener&lt;/code&gt; インスタンスがpayloadであるべき。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CAMERA_MOTION_LISTENER&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ExoPlayer.createMesssage()&lt;/code&gt; を通じてカメラモーションレンダラに渡されるメッセージ。&lt;br&gt;
&lt;code&gt;CameraMotionListener&lt;/code&gt; がpayloadであるべき。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SKIP_SILENCE_ENABLED&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ExoPlayer.createMesssage()&lt;/code&gt; を通じてオーディオレンダラに渡されるメッセージ。  &lt;br&gt;
無音をスキップするか否かをpayloadに渡します。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AUDIO_SESSION_ID&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ExoPlayer.createMesssage()&lt;/code&gt; を通じてビデオレンダラとオーディオレンダラに渡されるメッセージ。&lt;br&gt;
payloadはオーディオセッションIDを表すintで、下のオーディオトラックにアタッチされるもので、ビデオレンダラがトンネリングをサポートするなれば、オーディオセッションIDを利用します。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;WAKEUP_LISTENER&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ExoPlayer.createMesssage()&lt;/code&gt; を通じて &lt;code&gt;Renderer&lt;/code&gt; インターフェースに渡されるメッセージ。&lt;br&gt;
レンダラーが他のコンポーネントのウェイクアップが可能なことを知らせます。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.17.0/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FRenderer.java#L80-L204"&gt;Renderer.java#L80-L204&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;State&lt;/h2&gt;
&lt;p&gt;&lt;img src="https://exoplayer.dev/doc/reference/com/google/android/exoplayer2/doc-files/renderer-states.svg"/&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;DISABLED&lt;/p&gt;
&lt;p&gt;レンダラーが利用不可。メディアデコーダなどのレンダリングに必要なものを得ていません。もしかしたら継続的に利用可能なものを持っているかもしれません。&lt;br&gt;
&lt;code&gt;reset()&lt;/code&gt; を呼ぶことで強制的にそういった保持しているリソースを強制解放できます。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ENABLED&lt;/p&gt;
&lt;p&gt;レンダラーが利用可能だが始まってはいません。このステートは、初めのビデオフレームのような現在のポジションのメディアをレンダリングしているかもしれません。&lt;br&gt;
ですがポジションが先に進むことはありません。メディアデコーダなどのレンダリングに必要なリソースを保持していると考えるのが一般的なこのステートへの考え方です。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;STARTED&lt;/p&gt;
&lt;p&gt;レンダラーが始まっています。 &lt;code&gt;renderer()&lt;/code&gt; メソッドを飛ぶことでメディアのレンダーが始まります。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.17.0/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FRenderer.java#L206-L231"&gt;Renderer.java#L206-L231&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;getter&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;String getName()&lt;/code&gt;：ロギングやデバッグの目的のもので、レンダラーの名前を返します。レンダラーのクラスネームであることが一般的です。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@C.TrackType int getTrackType()&lt;/code&gt;：レンダラーがハンドリングしているトラックタイプを返します。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RendererCapabilities getCapabilities()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int getState()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;MediaClock getMediaClock()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;もしレンダラーが自身の再生ポジションを越える場合にこのメソッドが対応するMediaClockを返します。もし MediaClockが帰ったならばプレイヤーはそのMediaClockを使います。&lt;br&gt;
プレイヤーはこのメソッドから返された最低一つのレンダラーを持っているかもしれません。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;@Nullable SampleStream getStream()&lt;/code&gt;：もしレンダラーがdisabledならばnullが帰ります。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;long getReadingPositionUs()&lt;/code&gt;：rendererが読み込んだサンプルの時間を返します。 &lt;code&gt;STATE_ENABLED&lt;/code&gt; または &lt;code&gt;STATE_STARTED&lt;/code&gt; の時に呼ばれます。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boolean isCurrentStreamFinal()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;boolean hasReadStreamToEnd()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;このメソッドは &lt;code&gt;STATE_ENABLED&lt;/code&gt; または &lt;code&gt;STATE_STARTED&lt;/code&gt; の時に呼ばれます。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;boolean isEnded()&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;メソッド&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;void init(int index, PlayerId playerId)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;プレイヤーが再生に使おうとしているレンダラーが初期化されます。indexはプレイヤーの中のレンダラーインデックスでPlayerIdはプレイヤーのIDです。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;void enable(RendererConfiguration configuration, Format[] formats, SampleStream stream, long positonUs, boolean joining, boolean mayRendererStartOfStream, long startPositionUs, long offsetUs)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;レンダラーに指定した SampleStreamを消費することを可能にします。このメソッドはレンダラーが &lt;code&gt;STATE_DISABLED&lt;/code&gt; の時に呼ばれる可能性があります。
- format：利用可能なフォーマット
- positionUs：プレイヤーの現在のポジション
- joining：レンダラーを再生中のものに合流するかどうか
- mayRendererStartOfStream：レンダラーが &lt;code&gt;STATE_STARTED&lt;/code&gt; 出なくてもレンダラーがストリームを開始することを許可するかどうか
- startPositionUs：レンダラーの中の時間でのストリームの開始ポジション
- offsetUs： SampleStreamから読み込まれたバッファのタイムスタンプにレンダリング前に追加されるオフセットを指定します。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;void start()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;レンダラーを開始します。&lt;code&gt;render()&lt;/code&gt; を呼ぶことががレンダリングを開始することを意味しています。 &lt;code&gt;STATE_ENABLED&lt;/code&gt; の場合に呼ばれます。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;void replaceStream(Format[] formats, SampleStream stream, long startPositionUs, long offsetUs)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;SampleStreamを交換します。 &lt;code&gt;STATE_ENABLED&lt;/code&gt; と &lt;code&gt;STATE_STARTED&lt;/code&gt; の場合に呼ばれます。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;void setCurrentStreamFinal()&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;void maybeThrowStreamError() throws IOException&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;void resetPosition(long positionUs)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;PositionDiscontinuityが発生したことをレンダラーに知らせます。レンダラーのサンプルストリームはキーフレームから再生をすることを保証します。&lt;br&gt;
&lt;code&gt;STATE_ENABLED&lt;/code&gt; と &lt;code&gt;STATE_STARTED&lt;/code&gt; の場合に呼ばれます。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;default void setPlaybackSpeed(float currentPlaybackSpeed, float targetPlaybackSpeed)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;targetPlaybackSpeedは currentPlaybackSpeedとは異なります。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackException&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;SampleStreamをインクリメンタルにレンダリングします。&lt;br&gt;
レンダラーが{@link #STATE_ENABLED}の状態であれば、このメソッドを呼び出すたびにンダラーを起動したときに SampleStream をレンダリングできるようにするための作業を行います。もし レンダラーが STATE_STARTED の状態であれば、このメソッドを呼び出すと 指定されたメディアポジションに同期してSampleStreamを表示します。&lt;/p&gt;
&lt;p&gt;The renderer may also render the very start of the media at the current position (e.g. the
first frame of a video stream) while still in the {@link #STATE_ENABLED} state, unless it's the
initial start of the media after calling {@link #enable(RendererConfiguration, Format[],
SampleStream, long, boolean, boolean, long, long)} with {@code mayRenderStartOfStream} set to
{@code false}. （あまりにも長くて翻訳がだるい、DEEPLもダメだし。）&lt;/p&gt;
&lt;p&gt;このメソッドはすぐに返されるべきです。
&lt;code&gt;STATE_ENABLED&lt;/code&gt; と &lt;code&gt;STATE_STARTED&lt;/code&gt; の場合に呼ばれます。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;boolean isReady()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;If the renderer is in the {@link #STATE_STARTED} state then returning true indicates that
the renderer has everything that it needs to continue playback. Returning false indicates that
the player should pause until the renderer is ready.&lt;/p&gt;
&lt;p&gt;If the renderer is in the {@link #STATE_ENABLED} state then returning true indicates that
the renderer is ready for playback to be started. Returning false indicates that it is not.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;STATE_ENABLED&lt;/code&gt; と &lt;code&gt;STATE_STARTED&lt;/code&gt; の場合に呼ばれます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;void stop()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;STATE_ENABLED&lt;/code&gt;へ移行します
&lt;code&gt;STATE_STARTED&lt;/code&gt; の場合に呼ばれます。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;void disabled()&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;STATE_ENABLED&lt;/code&gt; の場合に呼ばれます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;reset()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;STATE_DISABLED&lt;/code&gt;の場合に呼ばれます。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;まとめ&lt;/h1&gt;
&lt;p&gt;render()メソッドの実実装と、getMediaClock()の実際の振る舞いが気になった。&lt;br&gt;
例えば音ズレの問題は &lt;code&gt;getMediaClock()&lt;/code&gt; が正しく振る舞えば起きないような気がする。&lt;/p&gt;
&lt;p&gt;長すぎて後半だるかった。&lt;/p&gt;</content><category term="ExoPlayer"></category></entry><entry><title>ExoPlayerにおけるLiveOffset</title><link href="/exoplayerniokeruliveoffset.html" rel="alternate"></link><published>2022-02-25T00:00:00+09:00</published><updated>2022-02-25T00:00:00+09:00</updated><author><name>dev-platong</name></author><id>tag:None,2022-02-25:/exoplayerniokeruliveoffset.html</id><summary type="html">&lt;h1&gt;Overview&lt;/h1&gt;
&lt;p&gt;ライブ再生に存在する概念であるライブオフセットについて扱います。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ライブオフセットとは何か&lt;/li&gt;
&lt;li&gt;ライブオフセ …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;h1&gt;Overview&lt;/h1&gt;
&lt;p&gt;ライブ再生に存在する概念であるライブオフセットについて扱います。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ライブオフセットとは何か&lt;/li&gt;
&lt;li&gt;ライブオフセットの決まり方&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;LiveOffsetとは&lt;/h1&gt;
&lt;p&gt;LiveOffsetは、現在の時刻から再生位置が何秒遅れているかを示します。 FROM: &lt;a href="https://github.com/google/ExoPlayer/blame/r2.17.1/docs/live-streaming.md#L11-L12"&gt;live-streaming.md#L11-L12&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="../images/getLiveOffsetUs.jpg" alt="ExoPlayerImplInternal Line 1108 getLiveOffsetUs function"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.17.1/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java#L1114-L1115"&gt;ExoPlayerImplInternal.java#L1114-L1115&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Player.getCurrentLiveOffset()&lt;/code&gt; で取得できます。 SEE: &lt;a href="https://exoplayer.dev/doc/reference/com/google/android/exoplayer2/Player.html#getCurrentLiveOffset()"&gt;Player.html#getCurrentLiveOffset()&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;LiveOffsetの決まり方&lt;/h1&gt;
&lt;h2&gt;HLSの場合&lt;/h2&gt;
&lt;p&gt;採択されるアルゴリズムにも優先順位がある。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;h1&gt;EXT-X-START がある場合&lt;/h1&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;マスタープレイリストまたはメディアプレイリストに記載される可能性があるタグです。&lt;br&gt;
記載されたプレイリストからの相対位置または、絶対位置で定義できます（絶対位置はおそらくMasterPlaylistに記載する想定だと思われます）。  &lt;/p&gt;
&lt;h1&gt;EXT-X-ENDLISTタグがプレイリストに含まれていない場合（ライブ再生）ではTARGET DURATIONの3倍以下の値を設定すべきではないことが示されています。&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://datatracker.ietf.org/doc/html/rfc8216#section-4.3.5.2"&gt;rfc8216#section-4.3.5.2&lt;/a&gt;で規定されています。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;h1&gt;EXT-X-SERVER-CONTROLにPART-HOLD-BACKが設定されていて、part target durationがある場合&lt;/h1&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Media Playlist限定のタグです。低遅延モードの時のプレイリストの終わりからの最小再生位置を示します。この値は最低でもPART TARGET DURATIONの2倍でなければいけません。また、PART TARGET DURATIONの3倍以上であるべきです。　　
もし異なるレンディションが異なるPART TARGET DURATIONsを持っているならば、PART-HOLD-BACKは最低でもPART TARGET DURATIONの3倍であるべきです。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis#section-4.4.3.8"&gt;draft-pantos-hls-rfc8216bis#section-4.4.3.8&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;PART TARGET DURATION&lt;/p&gt;
&lt;p&gt;&lt;a href="https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis#section-4.4.3.7"&gt;draft-pantos-hls-rfc8216bis#section-4.4.3.7&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;h1&gt;EXT-X-SERVER-CONTROLにHOLD-BACKが設定されている場合&lt;/h1&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Media Playlist限定のタグです。プレイリストの終わりからの最小再生位置を示します。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis#section-4.4.3.8"&gt;draft-pantos-hls-rfc8216bis#section-4.4.3.8&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;上記の項目が該当しない時&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;TARGET DURATIONの3倍になります。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-09#:~:text=Its%20absence%20implies%20a%20value%20of%20three%0A%20%20%20%20%20%20times%20the%20Target%20Duration."&gt;HLS spec 4.4.3.8&lt;/a&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;  &lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;   * Gets the target live offset, in microseconds, for a live playlist.&lt;/span&gt;
&lt;span class="cm"&gt;   *&lt;/span&gt;
&lt;span class="cm"&gt;   * &amp;lt;p&amp;gt;The target offset is derived by checking the following in this order:&lt;/span&gt;
&lt;span class="cm"&gt;   *&lt;/span&gt;
&lt;span class="cm"&gt;   * &amp;lt;ol&amp;gt;&lt;/span&gt;
&lt;span class="cm"&gt;   *   &amp;lt;li&amp;gt;The playlist defines a start offset.&lt;/span&gt;
&lt;span class="cm"&gt;   *   &amp;lt;li&amp;gt;The playlist defines a part hold back in server control and has part duration.&lt;/span&gt;
&lt;span class="cm"&gt;   *   &amp;lt;li&amp;gt;The playlist defines a hold back in server control.&lt;/span&gt;
&lt;span class="cm"&gt;   *   &amp;lt;li&amp;gt;Fallback to {@code 3 x target duration}.&lt;/span&gt;
&lt;span class="cm"&gt;   * &amp;lt;/ol&amp;gt;&lt;/span&gt;
&lt;span class="cm"&gt;   *&lt;/span&gt;
&lt;span class="cm"&gt;   * @param playlist The playlist.&lt;/span&gt;
&lt;span class="cm"&gt;   * @param liveEdgeOffsetUs The current live edge offset.&lt;/span&gt;
&lt;span class="cm"&gt;   * @return The selected target live offset, in microseconds.&lt;/span&gt;
&lt;span class="cm"&gt;   */&lt;/span&gt;
  &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="nf"&gt;getTargetLiveOffsetUs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;HlsMediaPlaylist&lt;/span&gt; &lt;span class="n"&gt;playlist&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;liveEdgeOffsetUs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;HlsMediaPlaylist&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ServerControl&lt;/span&gt; &lt;span class="n"&gt;serverControl&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;playlist&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;serverControl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;targetOffsetUs&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;playlist&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;startOffsetUs&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;TIME_UNSET&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;targetOffsetUs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;playlist&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;durationUs&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;playlist&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;startOffsetUs&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;serverControl&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;partHoldBackUs&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;TIME_UNSET&lt;/span&gt;
        &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;playlist&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;partTargetDurationUs&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;TIME_UNSET&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="c1"&gt;// Select part hold back only if the playlist has a part target duration.&lt;/span&gt;
      &lt;span class="n"&gt;targetOffsetUs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;serverControl&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;partHoldBackUs&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;serverControl&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;holdBackUs&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;TIME_UNSET&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;targetOffsetUs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;serverControl&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;holdBackUs&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="c1"&gt;// Fallback, see RFC 8216, Section 4.4.3.8.&lt;/span&gt;
      &lt;span class="n"&gt;targetOffsetUs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;playlist&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;targetDurationUs&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;targetOffsetUs&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;liveEdgeOffsetUs&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href="https://github.com/google/ExoPlayer/blob/r2.17.1/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java#L582-L614"&gt;HlsMediaSource.java#L582-L614&lt;/a&gt;&lt;/p&gt;</content><category term="ExoPlayer"></category></entry></feed>